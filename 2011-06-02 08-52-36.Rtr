##------ 02/06/2011 08:52:36 ------##

R version 2.13.0 (2011-04-13)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-apple-darwin9.8.0/x86_64 (64-bit)

R es un software libre y viene sin GARANTIA ALGUNA.
Usted puede redistribuirlo bajo ciertas circunstancias.
Escriba 'license()' o 'licence()' para detalles de distribucion.

R es un proyecto colaborativo con muchos contribuyentes.
Escriba 'contributors()' para obtener m'as informaci'on y
'citation()' para saber c'omo citar R o paquetes de R en publicaciones.

Escriba 'demo()' para demostraciones, 'help()' para el sistema on-line de ayuda,
o 'help.start()' para abrir el sistema de ayuda HTML con su navegador.
Escriba 'q()' para salir de R.

> require("inline")
Loading required package: inline
> require("Rcpp")
Loading required package: Rcpp
> 
> require("RUnit")
Loading required package: RUnit
> # Loading required package: RUnit
> 
> rm(list=ls(all.names=TRUE))
> 
> KnownActivationFunctions <- c("threshold", "logistic", "tanh", "identity", "exponential", "reciprocal", "square", "Gauss", "sine", "cosine", "Elliott", "arctan", "radialBasis")
> KnownNormalizationMethods <- c("none", "softmax", "simplemax")
> 
> source("pkg/AMORE/R/Con.R")
> source("pkg/AMORE/R/listAMORE.R")
> source("pkg/AMORE/R/listCon.R")
> source("pkg/AMORE/R/Neuron.R")
> source("pkg/AMORE/R/MLPneuron.R")
> source("pkg/AMORE/R/RBFneuron.R")
> source("pkg/AMORE/R/listNeuron.R")
> source("pkg/AMORE/R/listMLPneuron.R")
> source("pkg/AMORE/R/listRBFneuron.R")
> source("pkg/AMORE/R/mlpLayer.R")
> source("pkg/AMORE/R/rbfLayer.R")
> source("pkg/AMORE/R/listLayer.R")
> source("pkg/AMORE/R/listMLPlayer.R")
> source("pkg/AMORE/R/listRBFlayer.R")
> source("pkg/AMORE/R/neuralNetwork.R")
> source("pkg/AMORE/R/MLPneuralNetwork.R")
> source("pkg/AMORE/R/RBFneuralNetwork.R")
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		
+ 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 
+ 		// Test
+ 			MyvecCon.show() ;
+ 			MyvecCon.validate();		
+ 			return wrap(1);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
In file included from file2a3a72a6.cpp:36:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
In file included from /Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:9,
                 from file2a3a72a6.cpp:48:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
file2a3a72a6.cpp: In function 'SEXPREC* file2a3a72a6()':
file2a3a72a6.cpp:71: error: 'ConPtr' was not declared in this scope
file2a3a72a6.cpp:71: error: expected `;' before 'ptCon'
file2a3a72a6.cpp:72: error: 'ptCon' was not declared in this scope
make: *** [file2a3a72a6.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: 
 46: #ifndef INLINE_R
 47: 
 48: #include "Con.cpp"
 49: #include "vecAMORE.cpp"
 50: //#include "vecCon.cpp"
 51: #include "Neuron.cpp"
 52: 
 53: #endif /* INLINE_R_ */
 54: 
 55: 
 56: using namespace Rcpp;
 57: extern "C" {
 58:   SEXP file2a3a72a6 (  );
 59: }
 60: 
 61: SEXP file2a3a72a6 (  ) {
 62: 
 63: 		// Data set up
 64: 			Neuron N1, N2, N3;
 65: 			vecAMORE<Con> MyvecCon;
 66: 
 67: 			N1.setId(10);
 68: 			N2.setId(20);
 69: 			N3.setId(30);
 70: 		
 71: 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
 72: 			MyvecCon.push_back(ptCon);				// push_back 
 73: 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
 74: 			MyvecCon.push_back(ptCon);				// push_back
 75: 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
 76: 			MyvecCon.push_back(ptCon);				// push_back
 77: 
 78: 		// Test
 79: 			MyvecCon.show() ;
 80: 			MyvecCon.validate();		
 81: 			return wrap(1);
 82: 			
 83:   Rf_warning("your C program does not return anything!");
 84:   return R_NilValue;
 85: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! In file included from file2a3a72a6.cpp:36:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
In file included from /Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:9,
                 from file2a3a72a6.cpp:48:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file2a3a72a6.cpp 2> file2a3a72a6.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> 	checkEquals(result, 1)
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		
+ 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 
+ 		// Test
+ 			MyvecCon.show() ;
+ 			MyvecCon.validate();		
+ 			return wrap(1);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
In file included from file633d05f2.cpp:36:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
In file included from /Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:9,
                 from file633d05f2.cpp:48:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
file633d05f2.cpp: In function 'SEXPREC* file633d05f2()':
file633d05f2.cpp:71: error: 'ConPtr' was not declared in this scope
file633d05f2.cpp:71: error: expected `;' before 'ptCon'
file633d05f2.cpp:72: error: 'ptCon' was not declared in this scope
make: *** [file633d05f2.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: 
 46: #ifndef INLINE_R
 47: 
 48: #include "Con.cpp"
 49: #include "vecAMORE.cpp"
 50: //#include "vecCon.cpp"
 51: #include "Neuron.cpp"
 52: 
 53: #endif /* INLINE_R_ */
 54: 
 55: 
 56: using namespace Rcpp;
 57: extern "C" {
 58:   SEXP file633d05f2 (  );
 59: }
 60: 
 61: SEXP file633d05f2 (  ) {
 62: 
 63: 		// Data set up
 64: 			Neuron N1, N2, N3;
 65: 			vecAMORE<Con> MyvecCon;
 66: 
 67: 			N1.setId(10);
 68: 			N2.setId(20);
 69: 			N3.setId(30);
 70: 		
 71: 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
 72: 			MyvecCon.push_back(ptCon);				// push_back 
 73: 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
 74: 			MyvecCon.push_back(ptCon);				// push_back
 75: 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
 76: 			MyvecCon.push_back(ptCon);				// push_back
 77: 
 78: 		// Test
 79: 			MyvecCon.show() ;
 80: 			MyvecCon.validate();		
 81: 			return wrap(1);
 82: 			
 83:   Rf_warning("your C program does not return anything!");
 84:   return R_NilValue;
 85: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! In file included from file633d05f2.cpp:36:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: invalid type in declaration before ';' token
In file included from /Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:9,
                 from file633d05f2.cpp:48:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: 'T' was not declared in this scope
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:45: error: template argument 1 is invalid
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file633d05f2.cpp 2> file633d05f2.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> 	checkEquals(result, 1)
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		
+ 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 
+ 		// Test
+ 			MyvecCon.show() ;
+ 			MyvecCon.validate();		
+ 			return wrap(1);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
file3b5185c4.cpp: In function 'SEXPREC* file3b5185c4()':
file3b5185c4.cpp:71: error: 'ConPtr' was not declared in this scope
file3b5185c4.cpp:71: error: expected `;' before 'ptCon'
file3b5185c4.cpp:72: error: 'ptCon' was not declared in this scope
make: *** [file3b5185c4.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: 
 46: #ifndef INLINE_R
 47: 
 48: #include "Con.cpp"
 49: #include "vecAMORE.cpp"
 50: //#include "vecCon.cpp"
 51: #include "Neuron.cpp"
 52: 
 53: #endif /* INLINE_R_ */
 54: 
 55: 
 56: using namespace Rcpp;
 57: extern "C" {
 58:   SEXP file3b5185c4 (  );
 59: }
 60: 
 61: SEXP file3b5185c4 (  ) {
 62: 
 63: 		// Data set up
 64: 			Neuron N1, N2, N3;
 65: 			vecAMORE<Con> MyvecCon;
 66: 
 67: 			N1.setId(10);
 68: 			N2.setId(20);
 69: 			N3.setId(30);
 70: 		
 71: 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
 72: 			MyvecCon.push_back(ptCon);				// push_back 
 73: 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
 74: 			MyvecCon.push_back(ptCon);				// push_back
 75: 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
 76: 			MyvecCon.push_back(ptCon);				// push_back
 77: 
 78: 		// Test
 79: 			MyvecCon.show() ;
 80: 			MyvecCon.validate();		
 81: 			return wrap(1);
 82: 			
 83:   Rf_warning("your C program does not return anything!");
 84:   return R_NilValue;
 85: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file3b5185c4.cpp: In function 'SEXPREC* file3b5185c4()':
file3b5185c4.cpp:71: error: 'ConPtr' was not declared in this scope
file3b5185c4.cpp:71: error: expected `;' before 'ptCon'
file3b5185c4.cpp:72: error: 'ptCon' was not declared in this scope
make: *** [file3b5185c4.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file3b5185c4.cpp 2> file3b5185c4.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> 	checkEquals(result, 1)
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 
+ 		// Test
+ 			MyvecCon.show() ;
+ 			MyvecCon.validate();		
+ 			return wrap(1);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
> 	result <- testCodefun()
From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
> 	checkEquals(result, 1)
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<ConSharedPtr> vc;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 				
+ 			vc = MyvecCon.getLdata();
+ 			
+ 			result.push_back(vc.at(0)->getFromId());
+ 			result.push_back(vc.at(1)->getFromId());
+ 			result.push_back(vc.at(2)->getFromId());
+ 
+ 			return wrap(result);
+ 			'
> 	
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file69b2cdd8.cpp: In function 'SEXPREC* file69b2cdd8()':
file69b2cdd8.cpp:72: error: 'ConPtr' was not declared in this scope
file69b2cdd8.cpp:72: error: expected `;' before 'ptCon'
file69b2cdd8.cpp:73: error: 'ptCon' was not declared in this scope
make: *** [file69b2cdd8.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: 
 46: #ifndef INLINE_R
 47: 
 48: #include "Con.cpp"
 49: #include "vecAMORE.cpp"
 50: //#include "vecCon.cpp"
 51: #include "Neuron.cpp"
 52: 
 53: #endif /* INLINE_R_ */
 54: 
 55: 
 56: using namespace Rcpp;
 57: extern "C" {
 58:   SEXP file69b2cdd8 (  );
 59: }
 60: 
 61: SEXP file69b2cdd8 (  ) {
 62: 
 63: 		// Data set up
 64: 			Neuron N1, N2, N3;
 65: 			vecAMORE<Con> MyvecCon;
 66: 			std::vector<ConSharedPtr> vc;
 67: 			std::vector<int> result;
 68: 			N1.setId(10);
 69: 			N2.setId(20);
 70: 			N3.setId(30);
 71: 		// Test
 72: 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
 73: 			MyvecCon.push_back(ptCon);				// push_back 
 74: 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
 75: 			MyvecCon.push_back(ptCon);				// push_back
 76: 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
 77: 			MyvecCon.push_back(ptCon);				// push_back
 78: 				
 79: 			vc = MyvecCon.getLdata();
 80: 			
 81: 			result.push_back(vc.at(0)->getFromId());
 82: 			result.push_back(vc.at(1)->getFromId());
 83: 			result.push_back(vc.at(2)->getFromId());
 84: 
 85: 			return wrap(result);
 86: 			
 87:   Rf_warning("your C program does not return anything!");
 88:   return R_NilValue;
 89: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file69b2cdd8.cpp: In function 'SEXPREC* file69b2cdd8()':
file69b2cdd8.cpp:72: error: 'ConPtr' was not declared in this scope
file69b2cdd8.cpp:72: error: expected `;' before 'ptCon'
file69b2cdd8.cpp:73: error: 'ptCon' was not declared in this scope
make: *** [file69b2cdd8.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file69b2cdd8.cpp 2> file69b2cdd8.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
> 	checkEquals(result, c(10,20,30))
Error en checkEquals(result, c(10, 20, 30)) : 
  Numeric: lengths (1, 3) differ
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			result.push_back(MyvecCon.size());
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			result.push_back(MyvecCon.size());
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			result.push_back(MyvecCon.size());
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			result.push_back(MyvecCon.size());
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(0,1,2,3))
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<int> result;
+ 			std::vector<ConSharedPtr> vcA, vcB;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 
+ 		// Test
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			vcA.push_back(ptCon);				// push_back 
+ 			ptCon.reset( new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			vcA.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			vcA.push_back(ptCon);				// push_back
+ 		
+ 			MyvecCon.setLdata(vcA);
+ 			
+ 			vcB = MyvecCon.getLdata();
+ 			
+ 			result.push_back(vcB.at(0)->getFromId());
+ 			result.push_back(vcB.at(1)->getFromId());
+ 			result.push_back(vcB.at(2)->getFromId());
+ 			
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(10,20,30))
[1] TRUE
> // Data set up
Error: inesperado '/' en "/"
> 			Neuron N1, N2, N3;
Error: inesperado s'imbolo en "                        Neuron N1"
> 			vecAMORE<Con> MyvecCon;
Error: inesperado '>' en "                        vecAMORE<Con>"
> 			std::vector<ConSharedPtr> vc;
Error: inesperado '>' en "                        std::vector<ConSharedPtr>"
> 			std::vector<int> result;
Error: inesperado '>' en "                        std::vector<int>"
> 			N1.setId(10);
Error: no se pudo encontrar la funci'on "N1.setId"
> 			N2.setId(20);
Error: no se pudo encontrar la funci'on "N2.setId"
> 			N3.setId(30);
Error: no se pudo encontrar la funci'on "N3.setId"
> 		// Test
Error: inesperado '/' en "                /"
> 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
Error: inesperado s'imbolo en "                        ConPtr ptCon"
> 			MyvecCon.push_back(ptCon);				// push_back 
Error: no se pudo encontrar la funci'on "MyvecCon.push_back"
> 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
Error: inesperado s'imbolo en "                        ptCon.reset(  new Con"
> 			MyvecCon.push_back(ptCon);				// push_back
Error: no se pudo encontrar la funci'on "MyvecCon.push_back"
> 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
Error: inesperado s'imbolo en "                        ptCon.reset(  new Con"
> 			MyvecCon.push_back(ptCon);				// push_back
Error: no se pudo encontrar la funci'on "MyvecCon.push_back"
> 				
> 			vc = MyvecCon.getLdata();
Error: no se pudo encontrar la funci'on "MyvecCon.getLdata"
> 			
> 			result.push_back(vc.at(0)->getFromId());
Error: no se pudo encontrar la funci'on "result.push_back"
> 			result.push_back(vc.at(1)->getFromId());
Error: no se pudo encontrar la funci'on "result.push_back"
> 			result.push_back(vc.at(2)->getFromId());
Error: no se pudo encontrar la funci'on "result.push_back"
> 
> 			return wrap(result);
Error: inesperado s'imbolo en "                        return wrap"
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<ConSharedPtr> vc;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 				
+ 			vc = MyvecCon.getLdata();
+ 			
+ 			result.push_back(vc.at(0)->getFromId());
+ 			result.push_back(vc.at(1)->getFromId());
+ 			result.push_back(vc.at(2)->getFromId());
+ 
+ 			return wrap(result);
+ 			'
> 	
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file302362d8.cpp: In function 'SEXPREC* file302362d8()':
file302362d8.cpp:72: error: 'ConPtr' was not declared in this scope
file302362d8.cpp:72: error: expected `;' before 'ptCon'
file302362d8.cpp:73: error: 'ptCon' was not declared in this scope
make: *** [file302362d8.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: 
 46: #ifndef INLINE_R
 47: 
 48: #include "Con.cpp"
 49: #include "vecAMORE.cpp"
 50: //#include "vecCon.cpp"
 51: #include "Neuron.cpp"
 52: 
 53: #endif /* INLINE_R_ */
 54: 
 55: 
 56: using namespace Rcpp;
 57: extern "C" {
 58:   SEXP file302362d8 (  );
 59: }
 60: 
 61: SEXP file302362d8 (  ) {
 62: 
 63: 		// Data set up
 64: 			Neuron N1, N2, N3;
 65: 			vecAMORE<Con> MyvecCon;
 66: 			std::vector<ConSharedPtr> vc;
 67: 			std::vector<int> result;
 68: 			N1.setId(10);
 69: 			N2.setId(20);
 70: 			N3.setId(30);
 71: 		// Test
 72: 			ConPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
 73: 			MyvecCon.push_back(ptCon);				// push_back 
 74: 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
 75: 			MyvecCon.push_back(ptCon);				// push_back
 76: 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
 77: 			MyvecCon.push_back(ptCon);				// push_back
 78: 				
 79: 			vc = MyvecCon.getLdata();
 80: 			
 81: 			result.push_back(vc.at(0)->getFromId());
 82: 			result.push_back(vc.at(1)->getFromId());
 83: 			result.push_back(vc.at(2)->getFromId());
 84: 
 85: 			return wrap(result);
 86: 			
 87:   Rf_warning("your C program does not return anything!");
 88:   return R_NilValue;
 89: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file302362d8.cpp: In function 'SEXPREC* file302362d8()':
file302362d8.cpp:72: error: 'ConPtr' was not declared in this scope
file302362d8.cpp:72: error: expected `;' before 'ptCon'
file302362d8.cpp:73: error: 'ptCon' was not declared in this scope
make: *** [file302362d8.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file302362d8.cpp 2> file302362d8.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
> 	checkEquals(result, c(10,20,30))
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<ConSharedPtr> vc;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 				
+ 			vc = MyvecCon.getLdata();
+ 			
+ 			result.push_back(vc.at(0)->getFromId());
+ 			result.push_back(vc.at(1)->getFromId());
+ 			result.push_back(vc.at(2)->getFromId());
+ 
+ 			return wrap(result);
+ 			'
> 	
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(10,20,30))
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- "
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			Neuron * ptNeuron;
+ 			MyNeuron.setId(1);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			ptNeuron = myCon.getFromNeuron();
+ 			int result= ptNeuron->getId();
+ 			return wrap(result);
+ 			"
> 
> testCode
[1] "\n\t\t\tCon myCon;\n\t\t\tNeuron MyNeuron;\n\t\t\tNeuron * ptNeuron;\n\t\t\tMyNeuron.setId(1);\n\t\t\tmyCon.setFromNeuron(&MyNeuron);\n\t\t\t\n\t\t\tptNeuron = myCon.getFromNeuron();\n\t\t\tint result= ptNeuron->getId();\n\t\t\treturn wrap(result);\n\t\t\t"
> getwd()
[1] "/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC"
> dir()
[1] "2011-06-02 08-52-36.Rtr" "Doxyfile"               
[3] "README"                  "RunDoxy.sh"             
[5] "pkg"                     "www"                    
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- "
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			Neuron * ptNeuron;
+ 			MyNeuron.setId(1);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			ptNeuron = myCon.getFromNeuron();
+ 			int result= ptNeuron->getId();
+ 			return wrap(result);
+ 			"
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, 1)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			int result= myCon.getFromId();
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, 16)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			myCon.setWeight(12.4);
+ 			double result1= myCon.getWeight();
+ 			myCon.setWeight(2.2);
+ 			double result2= myCon.getWeight();
+ 			return Rcpp::List::create(	Rcpp::Named("R1")	= result1,
+ 			Rcpp::Named("R2") 	= result2);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
> 	result <- testCodefun()
> 	checkEquals(result$R1, 12.4)
[1] TRUE
> 	checkEquals(result$R2, 2.2)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			std::vector<double> result;
+ 			MyNeuron.setId(16);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			myCon.setWeight(12.4);
+ 			result.push_back(myCon.getWeight());
+ 			myCon.setWeight(2.2);
+ 			result.push_back(myCon.getWeight());
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
> 	result <- testCodefun()
> 	checkEquals(result, c(12.4, 2.2) )
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			Con myCon(&MyNeuron, 12.4);
+ 			bool result= myCon.show();
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	
> 	result <- testCodefun()
From:	 16 	 Weight= 	 12.400000 
> 	checkTrue(result)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			Con myCon(&MyNeuron, 12.4);
+ 			bool result= myCon.show();
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	
> 	result <- testCodefun()
From:	 16 	 Weight= 	 12.400000 
> 	checkTrue(result)
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- "
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			Neuron * ptNeuron;
+ 			MyNeuron.setId(1);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			ptNeuron = myCon.getFromNeuron();
+ 			int result= ptNeuron->getId();
+ 			return wrap(result);
+ 			"
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, 1)
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			int result= myCon.getFromId();
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, 16)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			Con myCon(&MyNeuron, 12.4/0);
+ 			myCon.validate();
+ 			return wrap(true);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file6f8eafd1.cpp: In function 'SEXPREC* file6f8eafd1()':
file6f8eafd1.cpp:65: warning: division by zero in '1.24000000000000003552713678800500929355621337890625e+1 / 0'
> 	
> 	checkException(result <- testCodefun(), silent=FALSE)
Error in testCodefun() : weight is not finite.
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		Neuron MyNeuron;
+ 			MyNeuron.setId(16);
+ 			Con myCon(&MyNeuron, 12.4/0);
+ 			myCon.validate();
+ 			return wrap(true);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
fileb8fb8f.cpp: In function 'SEXPREC* fileb8fb8f()':
fileb8fb8f.cpp:65: warning: division by zero in '1.24000000000000003552713678800500929355621337890625e+1 / 0'
> 	
> 	checkException(result <- testCodefun(), silent=TRUE)
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			Neuron MyNeuron;
+ 			MyNeuron.setId(NA_INTEGER);
+ 			Con myCon(&MyNeuron, 12.4);
+ 			myCon.validate();
+ 			return wrap(myCon.getFromId());
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	
> 	checkException(result <- testCodefun(), silent=TRUE)
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 
+ 		// Test
+ 			MyvecCon.show() ;
+ 			MyvecCon.validate();		
+ 			return wrap(1);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())	
> 	result <- testCodefun()
From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
> 	checkEquals(result, 1)
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<ConSharedPtr> vc;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 				
+ 			vc = MyvecCon.getLdata();
+ 			
+ 			result.push_back(vc.at(0)->getFromId());
+ 			result.push_back(vc.at(1)->getFromId());
+ 			result.push_back(vc.at(2)->getFromId());
+ 
+ 			return wrap(result);
+ 			'
> 	
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(10,20,30))
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 			// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<int> result;
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 		// Test
+ 			result.push_back(MyvecCon.size());
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back 
+ 			result.push_back(MyvecCon.size());
+ 			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			result.push_back(MyvecCon.size());
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			MyvecCon.push_back(ptCon);				// push_back
+ 			result.push_back(MyvecCon.size());
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(0,1,2,3))
[1] TRUE
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 		// Data set up
+ 			Neuron N1, N2, N3;
+ 			vecAMORE<Con> MyvecCon;
+ 			std::vector<int> result;
+ 			std::vector<ConSharedPtr> vcA, vcB;
+ 
+ 			N1.setId(10);
+ 			N2.setId(20);
+ 			N3.setId(30);
+ 
+ 		// Test
+ 			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
+ 			vcA.push_back(ptCon);				// push_back 
+ 			ptCon.reset( new Con(&N2, 2.22) );		// create new Con and assign to ptCon
+ 			vcA.push_back(ptCon);				// push_back
+ 			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
+ 			vcA.push_back(ptCon);				// push_back
+ 
+ 			MyvecCon.setLdata(vcA);
+ 			vcB = MyvecCon.getLdata();
+ 
+ 			result.push_back(vcB.at(0)->getFromId());
+ 			result.push_back(vcB.at(1)->getFromId());
+ 			result.push_back(vcB.at(2)->getFromId());			
+ 			return wrap(result);
+ 			'
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, c(10,20,30))
[1] TRUE
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- "
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			Neuron * ptNeuron;
+ 			MyNeuron.setId(1);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			ptNeuron = myCon.getFromNeuron();
+ 			int result= ptNeuron->getId();
+ 			return wrap(result);
+ 			"
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
In file included from file203ecea7.cpp:45:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:29: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:32: error: 'Con::~Con()' previously defined here
make: *** [file203ecea7.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: #include "Con.cpp"
 46: #include "vecAMORE.cpp"
 47: //#include "vecCon.cpp"
 48: #include "Neuron.cpp"
 49: 
 50: 
 51: using namespace Rcpp;
 52: extern "C" {
 53:   SEXP file203ecea7 (  );
 54: }
 55: 
 56: SEXP file203ecea7 (  ) {
 57: 
 58: 			Con myCon;
 59: 			Neuron MyNeuron;
 60: 			Neuron * ptNeuron;
 61: 			MyNeuron.setId(1);
 62: 			myCon.setFromNeuron(&MyNeuron);
 63: 			
 64: 			ptNeuron = myCon.getFromNeuron();
 65: 			int result= ptNeuron->getId();
 66: 			return wrap(result);
 67: 			
 68:   Rf_warning("your C program does not return anything!");
 69:   return R_NilValue;
 70: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! In file included from file203ecea7.cpp:45:
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:29: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.h:32: error: 'Con::~Con()' previously defined here
make: *** [file203ecea7.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file203ecea7.cpp 2> file203ecea7.cpp.err.txt' tiene estatus 1 
> 	result <- testCodefun()
> 	checkEquals(result, 1)
Error en checkEquals(result, 1) : Numeric: lengths (3, 1) differ
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- "
+ 			Con myCon;
+ 			Neuron MyNeuron;
+ 			Neuron * ptNeuron;
+ 			MyNeuron.setId(1);
+ 			myCon.setFromNeuron(&MyNeuron);
+ 			
+ 			ptNeuron = myCon.getFromNeuron();
+ 			int result= ptNeuron->getId();
+ 			return wrap(result);
+ 			"
> 	testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode,
+ 			otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(),
+ 			cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> 	result <- testCodefun()
> 	checkEquals(result, 1)
[1] TRUE
> 
> 
> require("inline")
> require("Rcpp")
> 
> require("RUnit")
> # Loading required package: RUnit
> 
> rm(list=ls(all.names=TRUE))
> 
> KnownActivationFunctions <- c("threshold", "logistic", "tanh", "identity", "exponential", "reciprocal", "square", "Gauss", "sine", "cosine", "Elliott", "arctan", "radialBasis")
> KnownNormalizationMethods <- c("none", "softmax", "simplemax")
> 
> source("pkg/AMORE/R/Con.R")
> source("pkg/AMORE/R/listAMORE.R")
> source("pkg/AMORE/R/listCon.R")
> source("pkg/AMORE/R/Neuron.R")
> source("pkg/AMORE/R/MLPneuron.R")
> source("pkg/AMORE/R/RBFneuron.R")
> source("pkg/AMORE/R/listNeuron.R")
> source("pkg/AMORE/R/listMLPneuron.R")
> source("pkg/AMORE/R/listRBFneuron.R")
> source("pkg/AMORE/R/mlpLayer.R")
> source("pkg/AMORE/R/rbfLayer.R")
> source("pkg/AMORE/R/listLayer.R")
> source("pkg/AMORE/R/listMLPlayer.R")
> source("pkg/AMORE/R/listRBFlayer.R")
> source("pkg/AMORE/R/neuralNetwork.R")
> source("pkg/AMORE/R/MLPneuralNetwork.R")
> source("pkg/AMORE/R/RBFneuralNetwork.R")
> 
> 
> source("pkg/AMORE/unitTest/unitTestSuite.R")


Executing test function test.Con.Cpp.getFromId  ...  done successfully.



Executing test function test.Con.Cpp.setFromNeuron.getFromNeuron  ...  done successfully.



Executing test function test.Con.Cpp.setWeight.getWeight  ...  done successfully.



Executing test function test.Con.Cpp.show  ... From:	 16 	 Weight= 	 12.400000 
 done successfully.



Executing test function test.Con.Cpp.validate.from  ...  done successfully.



Executing test function test.Con.Cpp.validate.weight  ... file665708.cpp: In function 'SEXPREC* file665708()':
file665708.cpp:60: warning: division by zero in '1.24000000000000003552713678800500929355621337890625e+1 / 0'
 done successfully.



Executing test function test.vecAMORE.Cpp.append  ... file3edbce6c.cpp: In function 'SEXPREC* file3edbce6c()':
file3edbce6c.cpp:85: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:86: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:87: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:88: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:89: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:90: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:98: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file3edbce6c.cpp:98: error: no match for 'operator!=' in 'itr != vecAMORE<T>::getLdata() [with T = Con]().std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
make: *** [file3edbce6c.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: #include "Con.cpp"
 46: #include "vecAMORE.cpp"
 47: //#include "vecCon.cpp"
 48: #include "Neuron.cpp"
 49: 
 50: 
 51: using namespace Rcpp;
 52: extern "C" {
 53:   SEXP file3edbce6c (  );
 54: }
 55: 
 56: SEXP file3edbce6c (  ) {
 57: 
 58: 		// Data set up
 59: 		Con Con1, Con2, Con3, Con4, Con5, Con6;
 60: 		Neuron N1, N2, N3, N4, N5, N6;
 61: 		vecAMORE<Con> vc1, vc2;
 62: 		std::vector<int> result;
 63: 		
 64: 		N1.setId(10);
 65: 		N2.setId(20);
 66: 		N3.setId(30);
 67: 		N4.setId(40);
 68: 		N5.setId(50);
 69: 		N6.setId(60);
 70: 		
 71: 		Con1.setFromNeuron(&N1);
 72: 		Con2.setFromNeuron(&N2);
 73: 		Con3.setFromNeuron(&N3);
 74: 		Con4.setFromNeuron(&N4);
 75: 		Con5.setFromNeuron(&N5);
 76: 		Con6.setFromNeuron(&N6);
 77: 		
 78: 		Con1.setWeight(1.01);
 79: 		Con2.setWeight(22.02);
 80: 		Con3.setWeight(333.03);			
 81: 		Con4.setWeight(5.4);
 82: 		Con5.setWeight(2.22);
 83: 		Con6.setWeight(33.03);			
 84: 		
 85: 		vc1.push_back(Con1);
 86: 		vc1.push_back(Con2);
 87: 		vc1.push_back(Con3);
 88: 		vc2.push_back(Con4);
 89: 		vc2.push_back(Con5);
 90: 		vc2.push_back(Con6);
 91: 		
 92: 		// Append test
 93: 		vc1.append(vc2);
 94: 		vc1.validate();		
 95: 		vc1.show() ;
 96: 		
 97: 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
 98: 		for(std::vector<Con>::iterator itr = (vc1.getLdata()).begin();   itr != (vc1.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
 99: 		return wrap(result);
100: 		
101:   Rf_warning("your C program does not return anything!");
102:   return R_NilValue;
103: }
Timing stopped at: 1.803 0.344 2.172 
Error in compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file3edbce6c.cpp: In function 'SEXPREC* file3edbce6c()':
file3edbce6c.cpp:85: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:86: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:87: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:88: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:89: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:90: error: no matching function for call to 'vecAMORE<Con>::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file3edbce6c.cpp:98: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file3edbce6c.cpp:98: error: no match for 'operator!=' in 'itr != vecAMORE<T>::getLdata() [with T = Con]().std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
make: *** [file3edbce6c.o] Error 1
Adem'as: Mensajes de aviso perdidos
1: In isValidTestSuite(testSuites) :
  'testSuite' object is not of class 'RUnitTestSuite'.
2: comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file3edbce6c.cpp 2> file3edbce6c.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.vecAMORE.Cpp.push_back  ...  done successfully.



Executing test function test.vecAMORE.Cpp.setLdata.getLdata  ...  done successfully.



Executing test function test.vecAMORE.Cpp.size  ...  done successfully.



Executing test function test.vecAMORE.Cpp.validate.show  ... From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.getFromId.show  ... file605736c4.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file605736c4.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file605736c4.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file605736c4.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file605736c4.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file605736c4.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file605736c4.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file605736c4.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file605736c4.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file605736c4.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file605736c4.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file605736c4.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file605736c4.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file605736c4.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file605736c4.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file605736c4.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file605736c4.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file605736c4.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file605736c4.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file605736c4.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file605736c4.cpp: At global scope:
file605736c4.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file605736c4.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file605736c4.cpp: In function 'SEXPREC* file605736c4()':
file605736c4.cpp:824: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file605736c4.cpp:825: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file605736c4.cpp:826: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file605736c4.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  */
485: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
486: 	ldata.reserve(ldata.size() + v.size());
487: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
488: };
489: 
490: 
491: //! %ldata field accessor function
492: /*!
493:  *  This method allows access to the data stored in the \ref ldata field.
494:  * \return The ldata vector.
495:  *
496:  * \code
497:  * 	//================
498:  *	//Usage example:
499:  *	//================
500:  *		// Data set up
501:  *			Neuron N1, N2, N3;
502:  *			vecAMORE<Con> MyvecCon;
503:  *			std::vector<int> result;
504:  *			std::vector<ConSharedPtr> vcA, vcB;
505:  *
506:  *			N1.setId(10);
507:  *			N2.setId(20);
508:  *			N3.setId(30);
509:  *
510:  *		// Test
511:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
512:  *			vcA.push_back(ptCon);						// push_back
513:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
514:  *			vcA.push_back(ptCon);						// push_back
515:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
516:  *			vcA.push_back(ptCon);						// push_back
517:  *
518:  *			MyvecCon.setLdata(vcA);
519:  *			vcB = MyvecCon.getLdata();
520:  *
521:  *			result.push_back(vcB.at(0)->getFromId());
522:  *			result.push_back(vcB.at(1)->getFromId());
523:  *			result.push_back(vcB.at(2)->getFromId());
524:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
525:  * \endcode
526:  *
527:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
528:  */
529: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
530: 	return ldata;
531: };
532: 
533: 
534: 
535: //! %ldata field accessor function
536: /*!
537:  *  This method sets the value of the data stored in the \ref ldata field.
538:  * \param v The vector of smart pointers to be stored in the ldata field
539:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
540:  */
541: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
542: 	ldata=v;
543: };
544: 
545: 
546: //! Returns the size or length of the vector
547: /*!
548:  *  This method returns the size of the vector.
549:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
550:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
551:  */
552: template <typename T> int vecAMORE<T>::size() {
553: 	return ldata.size() ;
554: };
555: 
556:  /*
557:  * vecCon.cpp
558:  *
559:  *  Created on: 26/05/2011
560:  *      Author: mcasl
561:  */
562: 
563: 
564: 
565: 
566: //! Size of the vecCon object
567: /*!
568:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
569:  * \return The size of the vector
570:  *
571:  *  \code
572:  *  //================
573:  *  //Usage example:
574:  *  //================
575:  * 	// Data set up
576:  *		Con Con1, Con2, Con3;
577:  *		Neuron N1, N2, N3;
578:  *		vecCon MyvecCon;
579:  *		std::vector<int> result;
580:  *
581:  *		N1.setId(10);
582:  *		N2.setId(20);
583:  *		N3.setId(30);
584:  *
585:  *		Con1.setFromNeuron(&N1);
586:  *		Con2.setFromNeuron(&N2);
587:  *		Con3.setFromNeuron(&N3);
588:  *
589:  *		Con1.setWeight(1.01);
590:  *		Con2.setWeight(22.02);
591:  *		Con3.setWeight(333.03);
592:  *
593:  *	// Test
594:  *		result.push_back(MyvecCon.numOfCons());
595:  *		MyvecCon.push_back(Con1);
596:  *		result.push_back(MyvecCon.numOfCons());
597:  *		MyvecCon.push_back(Con2);
598:  *		result.push_back(MyvecCon.numOfCons());
599:  *		MyvecCon.push_back(Con3);
600:  *		result.push_back(MyvecCon.numOfCons());
601:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
602:  * \endcode
603:  *
604:  * \sa vecAMORE::size (alias)
605:  */
606: int  vecCon::numOfCons() {
607: 	return ldata.size();
608: }
609: 
610: 
611: 
612: //! Getter of the Id values of the vector of Cons
613: /*!
614:  * This function returns the Id's of the neurons referred to by the vector of Cons.
615:  * \return An std::vector<int> that contains the Ids
616:  *
617:  * \code
618:  *  //================
619:  *  //Usage example:
620:  *  //================
621:  * 	// Data set up
622:  *		Con Con1, Con2, Con3;
623:  *		Neuron N1, N2, N3;
624:  *		vecCon MyvecCon;
625:  *		std::vector<int> result;
626:  *
627:  *		N1.setId(10);
628:  *		N2.setId(20);
629:  *		N3.setId(30);
630: 
631:  *		Con1.setFromNeuron(&N1);
632:  *		Con2.setFromNeuron(&N2);
633:  *		Con3.setFromNeuron(&N3);
634:  *
635:  *		Con1.setWeight(1.01);
636:  *		Con2.setWeight(22.02);
637:  *		Con3.setWeight(333.03);
638: 
639:  *		MyvecCon.push_back(Con1);
640:  *		MyvecCon.push_back(Con2);
641:  *		MyvecCon.push_back(Con3);
642: 
643:  *		MyvecCon.show() ;
644:  *		MyvecCon.validate();
645:  *
646:  *	// Test
647:  *		result=MyvecCon.getFromId();
648:  *	// Now result is a vector that contains the values 10, 20 and 30.
649:  *
650:  * \endcode
651:  */
652: std::vector<int>  vecCon::getFromId() {
653: 	std::vector<int> result;
654: 	result.reserve(numOfCons());
655: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
656: 	return result;
657: }
658: 
659: 
660: 
661: //
662: //
663: //
664: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
665: //
666: //	BEGIN_RCPP
667: //	Con con;
668: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
669: //	ldata.reserve(ldata.size() + FROM.size());
670: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
671: //
672: //		new();
673: //
674: //		ldata.push_back(
675: //		)
676: //	}
677: //
678: //
679: //	END_RCPP
680: //}
681: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
682: 
683: 
684: 
685: /*
686:  *
687:  * 	initialize=function(con, ...){
688: 					if (missing(con)){
689: 						callSuper(...)
690: 					} else {
691: 						push_back(con)
692: 						return(.self)
693: 					}
694: 				},
695: 
696: 
697: 				getWeight = function(FROM, ...){
698: 					if (missing(FROM)) {
699: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
700: 					} else {
701: 						return(select(FROM)$getWeight(...))
702: 					}
703: 				},
704: 
705: 				getFrom = function(...){
706: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
707: 				},
708: 
709: 
710: 				setWeight= function(value, FROM, ...) {
711: 					value <- c(value, recursive=TRUE)
712: 					if (missing(FROM)) {
713: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
714: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
715: 					} else {
716: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
717: 						myMatch <- match(FROM, getFromId(...))
718: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
719: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
720: 					}
721: 				},
722: 
723: 				setFrom= function(value, FROM, ...) {
724: 					value <- c(value, recursive=TRUE)
725: 					if (missing(FROM)) {
726: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
727: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
728: 					} else {
729: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
730: 						myMatch <- match(FROM, getFromId(...))
731: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
732: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
733: 					}
734: 				},
735: 
736: 				delete = function(FROM, ...) {
737: 					fromIds <- getFromId(...)
738: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
739: 					if (length(delIds)>0) {
740: 						ldata <<- ldata[-delIds]
741: 					}
742: 				},
743: 
744: 				select=function(FROM, ...){
745: 					fromObject <- getFromId(...)
746: 					myMatch <- match(FROM,  fromObject)
747: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
748: 					idx <- seq(along=ldata) [- myMatch]
749: 					selfClone <- copy(shallow=FALSE)
750: 					selfClone$delete(FROM=fromObject[idx])
751: 					return(selfClone)
752: 				},
753: 
754: 				numOfCons=function(...) {
755: 					return(length(ldata))
756: 				},
757: 
758: 				validate=function(...){
759: 					'Object validator for internal coherence.
760: 							'
761: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
762: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
763: 					lapply(ldata, function(x){x$validate(...)})
764: 					return(TRUE)
765:  *
766:  *
767:  */
768:  /*
769:  * Neuron.cpp
770:  *
771:  *  Created on: 25/05/2011
772:  *      Author: mcasl
773:  */
774: 
775: #ifndef INLINE_R
776: 
777: #include "Neuron.h"
778: 
779: #endif /* INLINE_R */
780: 
781: 
782: int Neuron::getId() {
783: 	return Id;
784: }
785: 
786: void Neuron::setId(int id) {
787: 	Id=id;
788: }
789: 
790: 
791: 
792: 
793: 
794: 
795: 
796: 
797: // declarations
798: extern "C" {
799: SEXP file605736c4( ) ;
800: }
801: 
802: // definition
803: 
804: SEXP file605736c4(  ){
805: BEGIN_RCPP
806: 
807: 		Con Con1, Con2, Con3;
808: 		Neuron N1, N2, N3;
809: 		vecCon MyvecCon;
810: 		std::vector<int> result;
811: 		
812: 		N1.setId(10);
813: 		N2.setId(20);
814: 		N3.setId(30);
815: 		
816: 		Con1.setFromNeuron(&N1);
817: 		Con2.setFromNeuron(&N2);
818: 		Con3.setFromNeuron(&N3);
819: 		
820: 		Con1.setWeight(1.01);
821: 		Con2.setWeight(22.02);
822: 		Con3.setWeight(333.03);			
823: 		
824: 		MyvecCon.push_back(Con1);
825: 		MyvecCon.push_back(Con2);
826: 		MyvecCon.push_back(Con3);
827: 		
828: 		MyvecCon.show() ;
829: 		MyvecCon.validate();
830: 		result=MyvecCon.getFromId();
831: 		
832: 		return wrap(result);
833: 		
834: 		
835: END_RCPP
836: }
837: 
838: 
Timing stopped at: 1.899 0.349 2.455 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file605736c4.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file605736c4.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file605736c4.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file605736c4.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file605736c4.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file605736c4.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file605736c4.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file605736c4.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file605736c4.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file605736c4.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file605736c4.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file605736c4.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file605736c4.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file605736c4.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file605736c4.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file605736c4.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file605736c4.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file605736c4.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file605736c4.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file605736c4.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file605736c4.cpp: At global scope:
file605736c4.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file605736c4.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file605736c4.cpp: In function 'SEXPREC* file605736c4()':
file605736c4.cpp:824: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file605736c4.cpp:825: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file605736c4.cpp:826: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file605736c4.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file605736c4.cpp 2> file605736c4.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.numOfCons  ... file7dccaf45.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file7dccaf45.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file7dccaf45.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file7dccaf45.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file7dccaf45.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file7dccaf45.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file7dccaf45.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file7dccaf45.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file7dccaf45.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file7dccaf45.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file7dccaf45.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file7dccaf45.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file7dccaf45.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file7dccaf45.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file7dccaf45.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file7dccaf45.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file7dccaf45.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file7dccaf45.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file7dccaf45.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file7dccaf45.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file7dccaf45.cpp: At global scope:
file7dccaf45.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file7dccaf45.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file7dccaf45.cpp: In function 'SEXPREC* file7dccaf45()':
file7dccaf45.cpp:827: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file7dccaf45.cpp:829: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file7dccaf45.cpp:831: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file7dccaf45.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  */
485: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
486: 	ldata.reserve(ldata.size() + v.size());
487: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
488: };
489: 
490: 
491: //! %ldata field accessor function
492: /*!
493:  *  This method allows access to the data stored in the \ref ldata field.
494:  * \return The ldata vector.
495:  *
496:  * \code
497:  * 	//================
498:  *	//Usage example:
499:  *	//================
500:  *		// Data set up
501:  *			Neuron N1, N2, N3;
502:  *			vecAMORE<Con> MyvecCon;
503:  *			std::vector<int> result;
504:  *			std::vector<ConSharedPtr> vcA, vcB;
505:  *
506:  *			N1.setId(10);
507:  *			N2.setId(20);
508:  *			N3.setId(30);
509:  *
510:  *		// Test
511:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
512:  *			vcA.push_back(ptCon);						// push_back
513:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
514:  *			vcA.push_back(ptCon);						// push_back
515:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
516:  *			vcA.push_back(ptCon);						// push_back
517:  *
518:  *			MyvecCon.setLdata(vcA);
519:  *			vcB = MyvecCon.getLdata();
520:  *
521:  *			result.push_back(vcB.at(0)->getFromId());
522:  *			result.push_back(vcB.at(1)->getFromId());
523:  *			result.push_back(vcB.at(2)->getFromId());
524:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
525:  * \endcode
526:  *
527:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
528:  */
529: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
530: 	return ldata;
531: };
532: 
533: 
534: 
535: //! %ldata field accessor function
536: /*!
537:  *  This method sets the value of the data stored in the \ref ldata field.
538:  * \param v The vector of smart pointers to be stored in the ldata field
539:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
540:  */
541: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
542: 	ldata=v;
543: };
544: 
545: 
546: //! Returns the size or length of the vector
547: /*!
548:  *  This method returns the size of the vector.
549:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
550:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
551:  */
552: template <typename T> int vecAMORE<T>::size() {
553: 	return ldata.size() ;
554: };
555: 
556:  /*
557:  * vecCon.cpp
558:  *
559:  *  Created on: 26/05/2011
560:  *      Author: mcasl
561:  */
562: 
563: 
564: 
565: 
566: //! Size of the vecCon object
567: /*!
568:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
569:  * \return The size of the vector
570:  *
571:  *  \code
572:  *  //================
573:  *  //Usage example:
574:  *  //================
575:  * 	// Data set up
576:  *		Con Con1, Con2, Con3;
577:  *		Neuron N1, N2, N3;
578:  *		vecCon MyvecCon;
579:  *		std::vector<int> result;
580:  *
581:  *		N1.setId(10);
582:  *		N2.setId(20);
583:  *		N3.setId(30);
584:  *
585:  *		Con1.setFromNeuron(&N1);
586:  *		Con2.setFromNeuron(&N2);
587:  *		Con3.setFromNeuron(&N3);
588:  *
589:  *		Con1.setWeight(1.01);
590:  *		Con2.setWeight(22.02);
591:  *		Con3.setWeight(333.03);
592:  *
593:  *	// Test
594:  *		result.push_back(MyvecCon.numOfCons());
595:  *		MyvecCon.push_back(Con1);
596:  *		result.push_back(MyvecCon.numOfCons());
597:  *		MyvecCon.push_back(Con2);
598:  *		result.push_back(MyvecCon.numOfCons());
599:  *		MyvecCon.push_back(Con3);
600:  *		result.push_back(MyvecCon.numOfCons());
601:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
602:  * \endcode
603:  *
604:  * \sa vecAMORE::size (alias)
605:  */
606: int  vecCon::numOfCons() {
607: 	return ldata.size();
608: }
609: 
610: 
611: 
612: //! Getter of the Id values of the vector of Cons
613: /*!
614:  * This function returns the Id's of the neurons referred to by the vector of Cons.
615:  * \return An std::vector<int> that contains the Ids
616:  *
617:  * \code
618:  *  //================
619:  *  //Usage example:
620:  *  //================
621:  * 	// Data set up
622:  *		Con Con1, Con2, Con3;
623:  *		Neuron N1, N2, N3;
624:  *		vecCon MyvecCon;
625:  *		std::vector<int> result;
626:  *
627:  *		N1.setId(10);
628:  *		N2.setId(20);
629:  *		N3.setId(30);
630: 
631:  *		Con1.setFromNeuron(&N1);
632:  *		Con2.setFromNeuron(&N2);
633:  *		Con3.setFromNeuron(&N3);
634:  *
635:  *		Con1.setWeight(1.01);
636:  *		Con2.setWeight(22.02);
637:  *		Con3.setWeight(333.03);
638: 
639:  *		MyvecCon.push_back(Con1);
640:  *		MyvecCon.push_back(Con2);
641:  *		MyvecCon.push_back(Con3);
642: 
643:  *		MyvecCon.show() ;
644:  *		MyvecCon.validate();
645:  *
646:  *	// Test
647:  *		result=MyvecCon.getFromId();
648:  *	// Now result is a vector that contains the values 10, 20 and 30.
649:  *
650:  * \endcode
651:  */
652: std::vector<int>  vecCon::getFromId() {
653: 	std::vector<int> result;
654: 	result.reserve(numOfCons());
655: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
656: 	return result;
657: }
658: 
659: 
660: 
661: //
662: //
663: //
664: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
665: //
666: //	BEGIN_RCPP
667: //	Con con;
668: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
669: //	ldata.reserve(ldata.size() + FROM.size());
670: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
671: //
672: //		new();
673: //
674: //		ldata.push_back(
675: //		)
676: //	}
677: //
678: //
679: //	END_RCPP
680: //}
681: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
682: 
683: 
684: 
685: /*
686:  *
687:  * 	initialize=function(con, ...){
688: 					if (missing(con)){
689: 						callSuper(...)
690: 					} else {
691: 						push_back(con)
692: 						return(.self)
693: 					}
694: 				},
695: 
696: 
697: 				getWeight = function(FROM, ...){
698: 					if (missing(FROM)) {
699: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
700: 					} else {
701: 						return(select(FROM)$getWeight(...))
702: 					}
703: 				},
704: 
705: 				getFrom = function(...){
706: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
707: 				},
708: 
709: 
710: 				setWeight= function(value, FROM, ...) {
711: 					value <- c(value, recursive=TRUE)
712: 					if (missing(FROM)) {
713: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
714: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
715: 					} else {
716: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
717: 						myMatch <- match(FROM, getFromId(...))
718: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
719: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
720: 					}
721: 				},
722: 
723: 				setFrom= function(value, FROM, ...) {
724: 					value <- c(value, recursive=TRUE)
725: 					if (missing(FROM)) {
726: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
727: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
728: 					} else {
729: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
730: 						myMatch <- match(FROM, getFromId(...))
731: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
732: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
733: 					}
734: 				},
735: 
736: 				delete = function(FROM, ...) {
737: 					fromIds <- getFromId(...)
738: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
739: 					if (length(delIds)>0) {
740: 						ldata <<- ldata[-delIds]
741: 					}
742: 				},
743: 
744: 				select=function(FROM, ...){
745: 					fromObject <- getFromId(...)
746: 					myMatch <- match(FROM,  fromObject)
747: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
748: 					idx <- seq(along=ldata) [- myMatch]
749: 					selfClone <- copy(shallow=FALSE)
750: 					selfClone$delete(FROM=fromObject[idx])
751: 					return(selfClone)
752: 				},
753: 
754: 				numOfCons=function(...) {
755: 					return(length(ldata))
756: 				},
757: 
758: 				validate=function(...){
759: 					'Object validator for internal coherence.
760: 							'
761: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
762: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
763: 					lapply(ldata, function(x){x$validate(...)})
764: 					return(TRUE)
765:  *
766:  *
767:  */
768:  /*
769:  * Neuron.cpp
770:  *
771:  *  Created on: 25/05/2011
772:  *      Author: mcasl
773:  */
774: 
775: #ifndef INLINE_R
776: 
777: #include "Neuron.h"
778: 
779: #endif /* INLINE_R */
780: 
781: 
782: int Neuron::getId() {
783: 	return Id;
784: }
785: 
786: void Neuron::setId(int id) {
787: 	Id=id;
788: }
789: 
790: 
791: 
792: 
793: 
794: 
795: 
796: 
797: // declarations
798: extern "C" {
799: SEXP file7dccaf45( ) ;
800: }
801: 
802: // definition
803: 
804: SEXP file7dccaf45(  ){
805: BEGIN_RCPP
806: 
807: 			// Data set up
808: 			Con Con1, Con2, Con3;
809: 			Neuron N1, N2, N3;
810: 			vecCon MyvecCon;
811: 			std::vector<int> result;
812: 			
813: 			N1.setId(10);
814: 			N2.setId(20);
815: 			N3.setId(30);
816: 			
817: 			Con1.setFromNeuron(&N1);
818: 			Con2.setFromNeuron(&N2);
819: 			Con3.setFromNeuron(&N3);
820: 			
821: 			Con1.setWeight(1.01);
822: 			Con2.setWeight(22.02);
823: 			Con3.setWeight(333.03);			
824: 			
825: 			// Test
826: 			result.push_back(MyvecCon.numOfCons());
827: 			MyvecCon.push_back(Con1);
828: 			result.push_back(MyvecCon.numOfCons());
829: 			MyvecCon.push_back(Con2);
830: 			result.push_back(MyvecCon.numOfCons());
831: 			MyvecCon.push_back(Con3);
832: 			result.push_back(MyvecCon.numOfCons());
833: 						
834: 			return wrap(result);
835: 			
836: END_RCPP
837: }
838: 
839: 
Timing stopped at: 1.908 0.331 2.3 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file7dccaf45.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file7dccaf45.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file7dccaf45.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file7dccaf45.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file7dccaf45.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file7dccaf45.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file7dccaf45.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file7dccaf45.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file7dccaf45.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file7dccaf45.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file7dccaf45.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file7dccaf45.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file7dccaf45.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file7dccaf45.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file7dccaf45.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file7dccaf45.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file7dccaf45.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file7dccaf45.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file7dccaf45.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file7dccaf45.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file7dccaf45.cpp: At global scope:
file7dccaf45.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file7dccaf45.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file7dccaf45.cpp: In function 'SEXPREC* file7dccaf45()':
file7dccaf45.cpp:827: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file7dccaf45.cpp:829: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file7dccaf45.cpp:831: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file7dccaf45.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file7dccaf45.cpp 2> file7dccaf45.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.gCon.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gCon.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gCon.getWeight  ...  done successfully.



Executing test function test.gCon.new_fromIsNeuron  ...  done successfully.



Executing test function test.gCon.new_fromIsNumeric  ...  done successfully.



Executing test function test.gCon.setFrom  ...  done successfully.



Executing test function test.gCon.setWeight  ...  done successfully.



Executing test function test.gCon.show  ... 
 From:  1 	 Weight:  14.5 done successfully.



Executing test function test.gCon.validate  ...  done successfully.



Executing test function test.gMLPneuron.new  ...  done successfully.



Executing test function test.gMLPneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Bias:  9.9
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gMLPneuron.validate  ...  done successfully.



Executing test function test.gNeuron.addCon  ...  done successfully.



Executing test function test.gNeuron.deleteCon  ...  done successfully.



Executing test function test.gNeuron.getCon  ...  done successfully.



Executing test function test.gNeuron.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gNeuron.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gNeuron.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gNeuron.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gNeuron.getWeight  ...  done successfully.



Executing test function test.gNeuron.new  ...  done successfully.



Executing test function test.gNeuron.numOfCons  ...  done successfully.



Executing test function test.gNeuron.setCon  ...  done successfully.



Executing test function test.gNeuron.setFrom  ...  done successfully.



Executing test function test.gNeuron.setId.getId  ...  done successfully.



Executing test function test.gNeuron.setWeight  ...  done successfully.



Executing test function test.gNeuron.show  ... 
------------------------

 Id:  1
------------------------

 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------
 done successfully.



Executing test function test.gNeuron.validate  ...  done successfully.



Executing test function test.gRBFneuron.new  ... 
------------------------------
 Id:  1
-----------------
 Width:  9.9
-----------------
 Altitude:  29.3
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gRBFneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Width:  9.9
-----------------
 Altitude:  29.3
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gRBFneuron.validate  ...  done successfully.



Executing test function test.gListAMORE.append  ...  done successfully.



Executing test function test.gListAMORE.getLdata  ...  done successfully.



Executing test function test.gListAMORE.new  ...  done successfully.



Executing test function test.gListAMORE.push_back  ...  done successfully.



Executing test function test.gListAMORE.setLdata  ...  done successfully.



Executing test function test.gListAMORE.show  ... 
 From:  1 	 Weight:  14.5
 From:  2 	 Weight:  24.5
 From:  3 	 Weight:  34.5 done successfully.



Executing test function test.gListAMORE.validate  ...  done successfully.



Executing test function test.gListCon.delete  ...  done successfully.



Executing test function test.gListCon.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.getWeight_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getWeight_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.new  ...  done successfully.



Executing test function test.gListCon.numOfCons  ...  done successfully.



Executing test function test.gListCon.populate_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.populate_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.push_back  ...  done successfully.



Executing test function test.gListCon.select  ...  done successfully.



Executing test function test.gListCon.setFrom  ...  done successfully.



Executing test function test.gListCon.setWeight  ...  done successfully.



Executing test function test.gListCon.show  ... 
 From:  1 	 Weight:  10
 From:  2 	 Weight:  9
 From:  3 	 Weight:  8
 From:  4 	 Weight:  7
 From:  5 	 Weight:  6
 From:  6 	 Weight:  5
 From:  7 	 Weight:  4
 From:  8 	 Weight:  3
 From:  9 	 Weight:  2
 From:  10 	 Weight:  1 done successfully.



Executing test function test.gListCon.validate  ...  done successfully.



Executing test function test.gListLayer.delete  ...  done successfully.



Executing test function test.gListLayer.getId  ...  done successfully.



Executing test function test.gListLayer.new_fromIsNeuron  ...  done successfully.



Executing test function test.gListLayer.new_fromIsNumeric  ...  done successfully.



Executing test function test.gListLayer.numOfLayers  ...  done successfully.



Executing test function test.gListLayer.select  ...  done successfully.



Executing test function test.glistMLPlayer.validate  ...  done successfully.



Executing test function test.gListMLPneuron.new  ...  done successfully.



Executing test function test.gListMLPneuron.populate_fromIsNeuron  ...  done successfully.



Executing test function test.gListMLPneuron.populate_fromIsNumeric  ...  done successfully.



Executing test function test.gListMLPneuron.setBias.getBias  ...  done successfully.



Executing test function test.gListMLPneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Bias:  1.1
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
------------------------------
------------------------------
 Id:  2
-----------------
 Bias:  3.4
------------------------------
 From:  1 	 Weight:  21
 From:  2 	 Weight:  22
 From:  3 	 Weight:  23
------------------------------
------------------------------
 Id:  3
-----------------
 Bias:  5.4
------------------------------
 From:  1 	 Weight:  31
 From:  2 	 Weight:  32
 From:  3 	 Weight:  33
------------------------------
------------------------------
 Id:  4
-----------------
 Bias:  9.8
------------------------------
 From:  1 	 Weight:  41
 From:  2 	 Weight:  42
 From:  3 	 Weight:  43
------------------------------
------------------------------
 Id:  5
-----------------
 Bias:  5.6
------------------------------
 From:  1 	 Weight:  51
 From:  2 	 Weight:  52
 From:  3 	 Weight:  53
------------------------------ done successfully.



Executing test function test.gListMLPneuron.validate  ...  done successfully.



Executing test function test.gListNeuron.delete  ...  done successfully.



Executing test function test.gListNeuron.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gListNeuron.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gListNeuron.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gListNeuron.is.regular  ...  done successfully.



Executing test function test.gListNeuron.new.push_back.numberOfNeurons.numOfCons  ...  done successfully.



Executing test function test.gListNeuron.select  ...  done successfully.



Executing test function test.gListNeuron.setFrom.getFrom  ...  done successfully.



Executing test function test.gListNeuron.setId.getId  ...  done successfully.



Executing test function test.gListNeuron.setWeight.getWeight  ...  done successfully.



Executing test function test.gListNeuron.show  ... 
------------------------

 Id:  1
------------------------

 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------

------------------------

 Id:  2
------------------------

 From:  1 	 Weight:  1
 From:  2 	 Weight:  2
 From:  3 	 Weight:  3
 From:  4 	 Weight:  4
 From:  5 	 Weight:  5
------------------------
 done successfully.



Executing test function test.gListNeuron.validate  ...  done successfully.



Executing test function test.gListRBFlayer.validate  ...  done successfully.



Executing test function test.gListRBFneuron.new  ...  done successfully.



Executing test function test.gListRBFneuron.populate  ...  done successfully.



Executing test function test.gListRBFneuron.setAltitude.getAltitude  ...  done successfully.



Executing test function test.gListRBFneuron.setWidth.getWidth  ...  done successfully.



Executing test function test.gListRBFneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Width:  1.1
-----------------
 Altitude:  1.9
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
------------------------------
------------------------------
 Id:  2
-----------------
 Width:  3.4
-----------------
 Altitude:  8.4
------------------------------
 From:  4 	 Weight:  21
 From:  5 	 Weight:  22
 From:  6 	 Weight:  23
------------------------------
------------------------------
 Id:  3
-----------------
 Width:  5.4
-----------------
 Altitude:  8.7
------------------------------
 From:  7 	 Weight:  31
 From:  8 	 Weight:  32
 From:  9 	 Weight:  33
------------------------------
------------------------------
 Id:  4
-----------------
 Width:  9.8
-----------------
 Altitude:  3.5
------------------------------
 From:  10 	 Weight:  41
 From:  11 	 Weight:  42
 From:  12 	 Weight:  43
------------------------------
------------------------------
 Id:  5
-----------------
 Width:  5.6
-----------------
 Altitude:  7.6
------------------------------
 From:  13 	 Weight:  51
 From:  14 	 Weight:  52
 From:  15 	 Weight:  53
------------------------------ done successfully.



Executing test function test.gListRBFneuron.validate  ...  done successfully.



Executing test function test.gmlpLayer.append  ...  done successfully.



Executing test function test.gmlpLayer.delete  ...  done successfully.



Executing test function test.gmlpLayer.is.regular  ...  done successfully.



Executing test function test.gmlpLayer.new  ...  done successfully.



Executing test function test.gmlpLayer.numOfCons  ...  done successfully.



Executing test function test.gmlpLayer.setAndGetWeight  ...  done successfully.



Executing test function test.gmlpLayer.setFrom.getFrom  ...  done successfully.



Executing test function test.gmlpLayer.setId.getId  ...  done successfully.



Executing test function test.gmlpLayer.validate  ...  done successfully.



Executing test function test.grbfLayer.append  ...  done successfully.



Executing test function test.grbfLayer.delete  ...  done successfully.



Executing test function test.grbfLayer.is.regular  ...  done successfully.



Executing test function test.grbfLayer.new  ...  done successfully.



Executing test function test.grbfLayer.numOfCons  ...  done successfully.



Executing test function test.grbfLayer.setFrom.getFrom  ...  done successfully.



Executing test function test.grbfLayer.setId.getId  ...  done successfully.



Executing test function test.grbfLayer.setWeight.getWeight  ...  done successfully.



Executing test function test.grbfLayer.validate  ...  done successfully.

Mensajes de aviso perdidos
1: In asMethod(object) : NAs introducidos por coerci'on
2: In asMethod(object) : NAs introducidos por coerci'on
3: In asMethod(object) : NAs introducidos por coerci'on
4: In asMethod(object) : NAs introducidos por coerci'on
5: In asMethod(object) : NAs introducidos por coerci'on
6: In class(value) <- "integer" : NAs introducidos por coerci'on
> 
> 
> 
> #lapply(gListCon$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gListAMORE$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gNeuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gMLPneuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gRBFneuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gListNeuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gListMLPneuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gListRBFneuron$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> #lapply(gNeuralLayer$methods(),FUN=function(x){cat("# TODO ",x, " unit test\n")}) -> DontMakeNoise
> 
> # TODO silent =TRUE in every call	
> 
> 
> 	incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 	// Data set up
+ 		Neuron N1, N2, N3, N4, N5, N6;
+ 		vecAMORE<Con> vcA, vcB;
+ 		std::vector<int> result;	
+ 		
+ 		N1.setId(10);
+ 		N2.setId(20);
+ 		N3.setId(30);
+ 		N4.setId(40);
+ 		N5.setId(50);
+ 		N6.setId(60);
+ 
+ 	// Test
+ 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
+ 		vcA.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N2, 2.22) );		
+ 		vcA.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N3, 3.33) );		
+ 		vcA.push_back(ptCon);					
+ 
+ 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
+ 		vcB.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N5, 2.22) );		
+ 		vcB.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N6, 3.33) );		
+ 		vcB.push_back(ptCon);					
+ 
+ 		// Append test
+ 		vcA.append(vcB);
+ 		vcA.validate();		
+ 		vcA.show() ;
+ 		
+ 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
+ 		for(std::vector<Con>::iterator itr = (vc1.getLdata()).begin();   itr != (vc1.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
+ 		return wrap(result);
+ 		'
> testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file9071b89.cpp: In function 'SEXPREC* file9071b89()':
file9071b89.cpp:91: error: 'vc1' was not declared in this scope
make: *** [file9071b89.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: #include "Con.cpp"
 46: #include "vecAMORE.cpp"
 47: //#include "vecCon.cpp"
 48: #include "Neuron.cpp"
 49: 
 50: 
 51: using namespace Rcpp;
 52: extern "C" {
 53:   SEXP file9071b89 (  );
 54: }
 55: 
 56: SEXP file9071b89 (  ) {
 57: 
 58: 	// Data set up
 59: 		Neuron N1, N2, N3, N4, N5, N6;
 60: 		vecAMORE<Con> vcA, vcB;
 61: 		std::vector<int> result;	
 62: 		
 63: 		N1.setId(10);
 64: 		N2.setId(20);
 65: 		N3.setId(30);
 66: 		N4.setId(40);
 67: 		N5.setId(50);
 68: 		N6.setId(60);
 69: 
 70: 	// Test
 71: 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
 72: 		vcA.push_back(ptCon);					 
 73: 		ptCon.reset( new Con(&N2, 2.22) );		
 74: 		vcA.push_back(ptCon);					
 75: 		ptCon.reset(  new Con(&N3, 3.33) );		
 76: 		vcA.push_back(ptCon);					
 77: 
 78: 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
 79: 		vcB.push_back(ptCon);					 
 80: 		ptCon.reset( new Con(&N5, 2.22) );		
 81: 		vcB.push_back(ptCon);					
 82: 		ptCon.reset(  new Con(&N6, 3.33) );		
 83: 		vcB.push_back(ptCon);					
 84: 
 85: 		// Append test
 86: 		vcA.append(vcB);
 87: 		vcA.validate();		
 88: 		vcA.show() ;
 89: 		
 90: 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
 91: 		for(std::vector<Con>::iterator itr = (vc1.getLdata()).begin();   itr != (vc1.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
 92: 		return wrap(result);
 93: 		
 94:   Rf_warning("your C program does not return anything!");
 95:   return R_NilValue;
 96: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file9071b89.cpp: In function 'SEXPREC* file9071b89()':
file9071b89.cpp:91: error: 'vc1' was not declared in this scope
make: *** [file9071b89.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file9071b89.cpp 2> file9071b89.cpp.err.txt' tiene estatus 1 
> result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> checkEquals(result, c(10,20,30,40,50,60))
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 	// Data set up
+ 		Neuron N1, N2, N3, N4, N5, N6;
+ 		vecAMORE<Con> vcA, vcB;
+ 		std::vector<int> result;	
+ 		
+ 		N1.setId(10);
+ 		N2.setId(20);
+ 		N3.setId(30);
+ 		N4.setId(40);
+ 		N5.setId(50);
+ 		N6.setId(60);
+ 
+ 	// Test
+ 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
+ 		vcA.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N2, 2.22) );		
+ 		vcA.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N3, 3.33) );		
+ 		vcA.push_back(ptCon);					
+ 
+ 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
+ 		vcB.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N5, 2.22) );		
+ 		vcB.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N6, 3.33) );		
+ 		vcB.push_back(ptCon);					
+ 
+ 		// Append test
+ 		vcA.append(vcB);
+ 		vcA.validate();		
+ 		vcA.show() ;
+ 		
+ 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
+ 		for(std::vector<Con>::iterator itr = (vcA.getLdata()).begin();   itr != (vcA.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
+ 		return wrap(result);
+ 		'
> testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file31a0c400.cpp: In function 'SEXPREC* file31a0c400()':
file31a0c400.cpp:91: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file31a0c400.cpp:91: error: no match for 'operator!=' in 'itr != vecAMORE<T>::getLdata() [with T = Con]().std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
make: *** [file31a0c400.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: #include "Con.cpp"
 46: #include "vecAMORE.cpp"
 47: //#include "vecCon.cpp"
 48: #include "Neuron.cpp"
 49: 
 50: 
 51: using namespace Rcpp;
 52: extern "C" {
 53:   SEXP file31a0c400 (  );
 54: }
 55: 
 56: SEXP file31a0c400 (  ) {
 57: 
 58: 	// Data set up
 59: 		Neuron N1, N2, N3, N4, N5, N6;
 60: 		vecAMORE<Con> vcA, vcB;
 61: 		std::vector<int> result;	
 62: 		
 63: 		N1.setId(10);
 64: 		N2.setId(20);
 65: 		N3.setId(30);
 66: 		N4.setId(40);
 67: 		N5.setId(50);
 68: 		N6.setId(60);
 69: 
 70: 	// Test
 71: 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
 72: 		vcA.push_back(ptCon);					 
 73: 		ptCon.reset( new Con(&N2, 2.22) );		
 74: 		vcA.push_back(ptCon);					
 75: 		ptCon.reset(  new Con(&N3, 3.33) );		
 76: 		vcA.push_back(ptCon);					
 77: 
 78: 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
 79: 		vcB.push_back(ptCon);					 
 80: 		ptCon.reset( new Con(&N5, 2.22) );		
 81: 		vcB.push_back(ptCon);					
 82: 		ptCon.reset(  new Con(&N6, 3.33) );		
 83: 		vcB.push_back(ptCon);					
 84: 
 85: 		// Append test
 86: 		vcA.append(vcB);
 87: 		vcA.validate();		
 88: 		vcA.show() ;
 89: 		
 90: 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
 91: 		for(std::vector<Con>::iterator itr = (vcA.getLdata()).begin();   itr != (vcA.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
 92: 		return wrap(result);
 93: 		
 94:   Rf_warning("your C program does not return anything!");
 95:   return R_NilValue;
 96: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file31a0c400.cpp: In function 'SEXPREC* file31a0c400()':
file31a0c400.cpp:91: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file31a0c400.cpp:91: error: no match for 'operator!=' in 'itr != vecAMORE<T>::getLdata() [with T = Con]().std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
make: *** [file31a0c400.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file31a0c400.cpp 2> file31a0c400.cpp.err.txt' tiene estatus 1 
> result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> checkEquals(result, c(10,20,30,40,50,60))
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 	// Data set up
+ 		Neuron N1, N2, N3, N4, N5, N6;
+ 		vecAMORE<Con> vcA, vcB;
+ 		std::vector<int> result;	
+ 		
+ 		N1.setId(10);
+ 		N2.setId(20);
+ 		N3.setId(30);
+ 		N4.setId(40);
+ 		N5.setId(50);
+ 		N6.setId(60);
+ 
+ 	// Test
+ 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
+ 		vcA.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N2, 2.22) );		
+ 		vcA.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N3, 3.33) );		
+ 		vcA.push_back(ptCon);					
+ 
+ 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
+ 		vcB.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N5, 2.22) );		
+ 		vcB.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N6, 3.33) );		
+ 		vcB.push_back(ptCon);					
+ 
+ 		// Append test
+ 		vcA.append(vcB);
+ 		vcA.validate();		
+ 		vcA.show() ;
+ 		
+ 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
+ 		for(std::vector<ConSharedPtr>::iterator itr = (vcA.getLdata()).begin();   itr != (vcA.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
+ 		return wrap(result);
+ 		'
> testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
file31a3f574.cpp: In function 'SEXPREC* file31a3f574()':
file31a3f574.cpp:91: error: 'class boost::shared_ptr<Con>' has no member named 'getFromId'
make: *** [file31a3f574.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: #include <Rcpp.h>
  2: 
  3: /*! \mainpage The AMORE++ package
  4:  *
  5:  * \section intro_sec Introduction
  6:  *
  7:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
  8:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
  9:  *
 10:  * \section motiv_sec Motivation
 11:  *
 12:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 13:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 14:  *
 15:  * \section RoadMap Road Map
 16:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 17:  *
 18:  */
 19: 
 20: 
 21: #include <iostream>
 22: #include <sstream>
 23: #include <algorithm>
 24: #include <vector>
 25: #include <boost/shared_ptr.hpp>
 26: #include <Rcpp.h>
 27: 
 28: using namespace Rcpp;
 29: 
 30: class Con;
 31: template <typename T> class vecAMORE;
 32: //class vecCon;
 33: class Neuron;
 34: 
 35: 
 36: #include "Con.h"
 37: 
 38: 
 39: 
 40: #include "vecAMORE.h"
 41: //#include "vecCon.h"
 42: #include "Neuron.h"
 43: 
 44: 
 45: #include "Con.cpp"
 46: #include "vecAMORE.cpp"
 47: //#include "vecCon.cpp"
 48: #include "Neuron.cpp"
 49: 
 50: 
 51: using namespace Rcpp;
 52: extern "C" {
 53:   SEXP file31a3f574 (  );
 54: }
 55: 
 56: SEXP file31a3f574 (  ) {
 57: 
 58: 	// Data set up
 59: 		Neuron N1, N2, N3, N4, N5, N6;
 60: 		vecAMORE<Con> vcA, vcB;
 61: 		std::vector<int> result;	
 62: 		
 63: 		N1.setId(10);
 64: 		N2.setId(20);
 65: 		N3.setId(30);
 66: 		N4.setId(40);
 67: 		N5.setId(50);
 68: 		N6.setId(60);
 69: 
 70: 	// Test
 71: 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
 72: 		vcA.push_back(ptCon);					 
 73: 		ptCon.reset( new Con(&N2, 2.22) );		
 74: 		vcA.push_back(ptCon);					
 75: 		ptCon.reset(  new Con(&N3, 3.33) );		
 76: 		vcA.push_back(ptCon);					
 77: 
 78: 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
 79: 		vcB.push_back(ptCon);					 
 80: 		ptCon.reset( new Con(&N5, 2.22) );		
 81: 		vcB.push_back(ptCon);					
 82: 		ptCon.reset(  new Con(&N6, 3.33) );		
 83: 		vcB.push_back(ptCon);					
 84: 
 85: 		// Append test
 86: 		vcA.append(vcB);
 87: 		vcA.validate();		
 88: 		vcA.show() ;
 89: 		
 90: 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
 91: 		for(std::vector<ConSharedPtr>::iterator itr = (vcA.getLdata()).begin();   itr != (vcA.getLdata()).end();   itr++)	{ result.push_back(itr->getFromId()); }
 92: 		return wrap(result);
 93: 		
 94:   Rf_warning("your C program does not return anything!");
 95:   return R_NilValue;
 96: }
Error en compileCode(f, code, language, verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file31a3f574.cpp: In function 'SEXPREC* file31a3f574()':
file31a3f574.cpp:91: error: 'class boost::shared_ptr<Con>' has no member named 'getFromId'
make: *** [file31a3f574.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file31a3f574.cpp 2> file31a3f574.cpp.err.txt' tiene estatus 1 
> result <- testCodefun()
Error: no se pudo encontrar la funci'on "testCodefun"
> checkEquals(result, c(10,20,30,40,50,60))
Error en all.equal(target, current, tolerance = tolerance, ...) : 
  objeto 'result' no encontrado
> incCode <-	paste(readLines( "pkg/AMORE/src/AMORE.h"),	collapse = "\n" )
> 	testCode <- '
+ 	// Data set up
+ 		Neuron N1, N2, N3, N4, N5, N6;
+ 		vecAMORE<Con> vcA, vcB;
+ 		std::vector<int> result;	
+ 		
+ 		N1.setId(10);
+ 		N2.setId(20);
+ 		N3.setId(30);
+ 		N4.setId(40);
+ 		N5.setId(50);
+ 		N6.setId(60);
+ 
+ 	// Test
+ 		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons 
+ 		vcA.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N2, 2.22) );		
+ 		vcA.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N3, 3.33) );		
+ 		vcA.push_back(ptCon);					
+ 
+ 		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
+ 		vcB.push_back(ptCon);					 
+ 		ptCon.reset( new Con(&N5, 2.22) );		
+ 		vcB.push_back(ptCon);					
+ 		ptCon.reset(  new Con(&N6, 3.33) );		
+ 		vcB.push_back(ptCon);					
+ 
+ 		// Append test
+ 		vcA.append(vcB);
+ 		vcA.validate();		
+ 		vcA.show() ;
+ 		
+ 		// Get Ids (vecAMORE does not know about vecCon::getFromId yet, thus the loop)		
+ 		for(std::vector<ConSharedPtr>::iterator itr = (vcA.getLdata()).begin();   itr != (vcA.getLdata()).end();   itr++)	{ result.push_back((*itr)->getFromId()); }
+ 		return wrap(result);
+ 		'
> testCodefun <- cfunction(sig=signature(), body=testCode,includes=incCode, otherdefs="using namespace Rcpp;", language="C++", verbose=FALSE, convention=".Call",Rcpp=TRUE,cppargs=character(), cxxargs= paste("-I",getwd(),"/pkg/AMORE/src -I/opt/local/include",sep=""), libargs=character())
> result <- testCodefun()
From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
From:	 40 	 Weight= 	 1.130000 
From:	 50 	 Weight= 	 2.220000 
From:	 60 	 Weight= 	 3.330000 
> checkEquals(result, c(10,20,30,40,50,60))
[1] TRUE
> 
> 
> source("pkg/AMORE/unitTest/unitTestSuite.R")


Executing test function test.Con.Cpp.getFromId  ...  done successfully.



Executing test function test.Con.Cpp.setFromNeuron.getFromNeuron  ...  done successfully.



Executing test function test.Con.Cpp.setWeight.getWeight  ...  done successfully.



Executing test function test.Con.Cpp.show  ... From:	 16 	 Weight= 	 12.400000 
 done successfully.



Executing test function test.Con.Cpp.validate.from  ...  done successfully.



Executing test function test.Con.Cpp.validate.weight  ... file5a17492e.cpp: In function 'SEXPREC* file5a17492e()':
file5a17492e.cpp:60: warning: division by zero in '1.24000000000000003552713678800500929355621337890625e+1 / 0'
 done successfully.



Executing test function test.vecAMORE.Cpp.append  ... From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
From:	 40 	 Weight= 	 1.130000 
From:	 50 	 Weight= 	 2.220000 
From:	 60 	 Weight= 	 3.330000 
 done successfully.



Executing test function test.vecAMORE.Cpp.push_back  ...  done successfully.



Executing test function test.vecAMORE.Cpp.setLdata.getLdata  ...  done successfully.



Executing test function test.vecAMORE.Cpp.size  ...  done successfully.



Executing test function test.vecAMORE.Cpp.validate.show  ... From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.getFromId.show  ... file9504306.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file9504306.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file9504306.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file9504306.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file9504306.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file9504306.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file9504306.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file9504306.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file9504306.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file9504306.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file9504306.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file9504306.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file9504306.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file9504306.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file9504306.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file9504306.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file9504306.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file9504306.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file9504306.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file9504306.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file9504306.cpp: At global scope:
file9504306.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file9504306.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file9504306.cpp: In function 'SEXPREC* file9504306()':
file9504306.cpp:824: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file9504306.cpp:825: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file9504306.cpp:826: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file9504306.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  */
485: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
486: 	ldata.reserve(ldata.size() + v.size());
487: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
488: };
489: 
490: 
491: //! %ldata field accessor function
492: /*!
493:  *  This method allows access to the data stored in the \ref ldata field.
494:  * \return The ldata vector.
495:  *
496:  * \code
497:  * 	//================
498:  *	//Usage example:
499:  *	//================
500:  *		// Data set up
501:  *			Neuron N1, N2, N3;
502:  *			vecAMORE<Con> MyvecCon;
503:  *			std::vector<int> result;
504:  *			std::vector<ConSharedPtr> vcA, vcB;
505:  *
506:  *			N1.setId(10);
507:  *			N2.setId(20);
508:  *			N3.setId(30);
509:  *
510:  *		// Test
511:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
512:  *			vcA.push_back(ptCon);						// push_back
513:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
514:  *			vcA.push_back(ptCon);						// push_back
515:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
516:  *			vcA.push_back(ptCon);						// push_back
517:  *
518:  *			MyvecCon.setLdata(vcA);
519:  *			vcB = MyvecCon.getLdata();
520:  *
521:  *			result.push_back(vcB.at(0)->getFromId());
522:  *			result.push_back(vcB.at(1)->getFromId());
523:  *			result.push_back(vcB.at(2)->getFromId());
524:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
525:  * \endcode
526:  *
527:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
528:  */
529: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
530: 	return ldata;
531: };
532: 
533: 
534: 
535: //! %ldata field accessor function
536: /*!
537:  *  This method sets the value of the data stored in the \ref ldata field.
538:  * \param v The vector of smart pointers to be stored in the ldata field
539:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
540:  */
541: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
542: 	ldata=v;
543: };
544: 
545: 
546: //! Returns the size or length of the vector
547: /*!
548:  *  This method returns the size of the vector.
549:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
550:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
551:  */
552: template <typename T> int vecAMORE<T>::size() {
553: 	return ldata.size() ;
554: };
555: 
556:  /*
557:  * vecCon.cpp
558:  *
559:  *  Created on: 26/05/2011
560:  *      Author: mcasl
561:  */
562: 
563: 
564: 
565: 
566: //! Size of the vecCon object
567: /*!
568:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
569:  * \return The size of the vector
570:  *
571:  *  \code
572:  *  //================
573:  *  //Usage example:
574:  *  //================
575:  * 	// Data set up
576:  *		Con Con1, Con2, Con3;
577:  *		Neuron N1, N2, N3;
578:  *		vecCon MyvecCon;
579:  *		std::vector<int> result;
580:  *
581:  *		N1.setId(10);
582:  *		N2.setId(20);
583:  *		N3.setId(30);
584:  *
585:  *		Con1.setFromNeuron(&N1);
586:  *		Con2.setFromNeuron(&N2);
587:  *		Con3.setFromNeuron(&N3);
588:  *
589:  *		Con1.setWeight(1.01);
590:  *		Con2.setWeight(22.02);
591:  *		Con3.setWeight(333.03);
592:  *
593:  *	// Test
594:  *		result.push_back(MyvecCon.numOfCons());
595:  *		MyvecCon.push_back(Con1);
596:  *		result.push_back(MyvecCon.numOfCons());
597:  *		MyvecCon.push_back(Con2);
598:  *		result.push_back(MyvecCon.numOfCons());
599:  *		MyvecCon.push_back(Con3);
600:  *		result.push_back(MyvecCon.numOfCons());
601:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
602:  * \endcode
603:  *
604:  * \sa vecAMORE::size (alias)
605:  */
606: int  vecCon::numOfCons() {
607: 	return ldata.size();
608: }
609: 
610: 
611: 
612: //! Getter of the Id values of the vector of Cons
613: /*!
614:  * This function returns the Id's of the neurons referred to by the vector of Cons.
615:  * \return An std::vector<int> that contains the Ids
616:  *
617:  * \code
618:  *  //================
619:  *  //Usage example:
620:  *  //================
621:  * 	// Data set up
622:  *		Con Con1, Con2, Con3;
623:  *		Neuron N1, N2, N3;
624:  *		vecCon MyvecCon;
625:  *		std::vector<int> result;
626:  *
627:  *		N1.setId(10);
628:  *		N2.setId(20);
629:  *		N3.setId(30);
630: 
631:  *		Con1.setFromNeuron(&N1);
632:  *		Con2.setFromNeuron(&N2);
633:  *		Con3.setFromNeuron(&N3);
634:  *
635:  *		Con1.setWeight(1.01);
636:  *		Con2.setWeight(22.02);
637:  *		Con3.setWeight(333.03);
638: 
639:  *		MyvecCon.push_back(Con1);
640:  *		MyvecCon.push_back(Con2);
641:  *		MyvecCon.push_back(Con3);
642: 
643:  *		MyvecCon.show() ;
644:  *		MyvecCon.validate();
645:  *
646:  *	// Test
647:  *		result=MyvecCon.getFromId();
648:  *	// Now result is a vector that contains the values 10, 20 and 30.
649:  *
650:  * \endcode
651:  */
652: std::vector<int>  vecCon::getFromId() {
653: 	std::vector<int> result;
654: 	result.reserve(numOfCons());
655: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
656: 	return result;
657: }
658: 
659: 
660: 
661: //
662: //
663: //
664: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
665: //
666: //	BEGIN_RCPP
667: //	Con con;
668: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
669: //	ldata.reserve(ldata.size() + FROM.size());
670: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
671: //
672: //		new();
673: //
674: //		ldata.push_back(
675: //		)
676: //	}
677: //
678: //
679: //	END_RCPP
680: //}
681: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
682: 
683: 
684: 
685: /*
686:  *
687:  * 	initialize=function(con, ...){
688: 					if (missing(con)){
689: 						callSuper(...)
690: 					} else {
691: 						push_back(con)
692: 						return(.self)
693: 					}
694: 				},
695: 
696: 
697: 				getWeight = function(FROM, ...){
698: 					if (missing(FROM)) {
699: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
700: 					} else {
701: 						return(select(FROM)$getWeight(...))
702: 					}
703: 				},
704: 
705: 				getFrom = function(...){
706: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
707: 				},
708: 
709: 
710: 				setWeight= function(value, FROM, ...) {
711: 					value <- c(value, recursive=TRUE)
712: 					if (missing(FROM)) {
713: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
714: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
715: 					} else {
716: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
717: 						myMatch <- match(FROM, getFromId(...))
718: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
719: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
720: 					}
721: 				},
722: 
723: 				setFrom= function(value, FROM, ...) {
724: 					value <- c(value, recursive=TRUE)
725: 					if (missing(FROM)) {
726: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
727: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
728: 					} else {
729: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
730: 						myMatch <- match(FROM, getFromId(...))
731: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
732: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
733: 					}
734: 				},
735: 
736: 				delete = function(FROM, ...) {
737: 					fromIds <- getFromId(...)
738: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
739: 					if (length(delIds)>0) {
740: 						ldata <<- ldata[-delIds]
741: 					}
742: 				},
743: 
744: 				select=function(FROM, ...){
745: 					fromObject <- getFromId(...)
746: 					myMatch <- match(FROM,  fromObject)
747: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
748: 					idx <- seq(along=ldata) [- myMatch]
749: 					selfClone <- copy(shallow=FALSE)
750: 					selfClone$delete(FROM=fromObject[idx])
751: 					return(selfClone)
752: 				},
753: 
754: 				numOfCons=function(...) {
755: 					return(length(ldata))
756: 				},
757: 
758: 				validate=function(...){
759: 					'Object validator for internal coherence.
760: 							'
761: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
762: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
763: 					lapply(ldata, function(x){x$validate(...)})
764: 					return(TRUE)
765:  *
766:  *
767:  */
768:  /*
769:  * Neuron.cpp
770:  *
771:  *  Created on: 25/05/2011
772:  *      Author: mcasl
773:  */
774: 
775: #ifndef INLINE_R
776: 
777: #include "Neuron.h"
778: 
779: #endif /* INLINE_R */
780: 
781: 
782: int Neuron::getId() {
783: 	return Id;
784: }
785: 
786: void Neuron::setId(int id) {
787: 	Id=id;
788: }
789: 
790: 
791: 
792: 
793: 
794: 
795: 
796: 
797: // declarations
798: extern "C" {
799: SEXP file9504306( ) ;
800: }
801: 
802: // definition
803: 
804: SEXP file9504306(  ){
805: BEGIN_RCPP
806: 
807: 		Con Con1, Con2, Con3;
808: 		Neuron N1, N2, N3;
809: 		vecCon MyvecCon;
810: 		std::vector<int> result;
811: 		
812: 		N1.setId(10);
813: 		N2.setId(20);
814: 		N3.setId(30);
815: 		
816: 		Con1.setFromNeuron(&N1);
817: 		Con2.setFromNeuron(&N2);
818: 		Con3.setFromNeuron(&N3);
819: 		
820: 		Con1.setWeight(1.01);
821: 		Con2.setWeight(22.02);
822: 		Con3.setWeight(333.03);			
823: 		
824: 		MyvecCon.push_back(Con1);
825: 		MyvecCon.push_back(Con2);
826: 		MyvecCon.push_back(Con3);
827: 		
828: 		MyvecCon.show() ;
829: 		MyvecCon.validate();
830: 		result=MyvecCon.getFromId();
831: 		
832: 		return wrap(result);
833: 		
834: 		
835: END_RCPP
836: }
837: 
838: 
Timing stopped at: 1.892 0.341 2.313 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file9504306.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file9504306.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file9504306.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file9504306.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file9504306.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file9504306.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file9504306.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file9504306.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file9504306.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file9504306.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file9504306.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file9504306.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file9504306.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file9504306.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file9504306.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file9504306.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file9504306.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file9504306.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file9504306.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file9504306.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file9504306.cpp: At global scope:
file9504306.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file9504306.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file9504306.cpp: In function 'SEXPREC* file9504306()':
file9504306.cpp:824: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file9504306.cpp:825: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file9504306.cpp:826: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file9504306.o] Error 1
Adem'as: Mensajes de aviso perdidos
1: In isValidTestSuite(testSuites) :
  'testSuite' object is not of class 'RUnitTestSuite'.
2: comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file9504306.cpp 2> file9504306.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.numOfCons  ... file746043b0.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file746043b0.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file746043b0.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file746043b0.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file746043b0.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file746043b0.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file746043b0.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file746043b0.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file746043b0.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file746043b0.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file746043b0.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file746043b0.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file746043b0.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file746043b0.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file746043b0.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file746043b0.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file746043b0.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file746043b0.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file746043b0.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file746043b0.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file746043b0.cpp: At global scope:
file746043b0.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file746043b0.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file746043b0.cpp: In function 'SEXPREC* file746043b0()':
file746043b0.cpp:827: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file746043b0.cpp:829: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file746043b0.cpp:831: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file746043b0.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  */
485: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
486: 	ldata.reserve(ldata.size() + v.size());
487: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
488: };
489: 
490: 
491: //! %ldata field accessor function
492: /*!
493:  *  This method allows access to the data stored in the \ref ldata field.
494:  * \return The ldata vector.
495:  *
496:  * \code
497:  * 	//================
498:  *	//Usage example:
499:  *	//================
500:  *		// Data set up
501:  *			Neuron N1, N2, N3;
502:  *			vecAMORE<Con> MyvecCon;
503:  *			std::vector<int> result;
504:  *			std::vector<ConSharedPtr> vcA, vcB;
505:  *
506:  *			N1.setId(10);
507:  *			N2.setId(20);
508:  *			N3.setId(30);
509:  *
510:  *		// Test
511:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
512:  *			vcA.push_back(ptCon);						// push_back
513:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
514:  *			vcA.push_back(ptCon);						// push_back
515:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
516:  *			vcA.push_back(ptCon);						// push_back
517:  *
518:  *			MyvecCon.setLdata(vcA);
519:  *			vcB = MyvecCon.getLdata();
520:  *
521:  *			result.push_back(vcB.at(0)->getFromId());
522:  *			result.push_back(vcB.at(1)->getFromId());
523:  *			result.push_back(vcB.at(2)->getFromId());
524:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
525:  * \endcode
526:  *
527:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
528:  */
529: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
530: 	return ldata;
531: };
532: 
533: 
534: 
535: //! %ldata field accessor function
536: /*!
537:  *  This method sets the value of the data stored in the \ref ldata field.
538:  * \param v The vector of smart pointers to be stored in the ldata field
539:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
540:  */
541: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
542: 	ldata=v;
543: };
544: 
545: 
546: //! Returns the size or length of the vector
547: /*!
548:  *  This method returns the size of the vector.
549:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
550:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
551:  */
552: template <typename T> int vecAMORE<T>::size() {
553: 	return ldata.size() ;
554: };
555: 
556:  /*
557:  * vecCon.cpp
558:  *
559:  *  Created on: 26/05/2011
560:  *      Author: mcasl
561:  */
562: 
563: 
564: 
565: 
566: //! Size of the vecCon object
567: /*!
568:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
569:  * \return The size of the vector
570:  *
571:  *  \code
572:  *  //================
573:  *  //Usage example:
574:  *  //================
575:  * 	// Data set up
576:  *		Con Con1, Con2, Con3;
577:  *		Neuron N1, N2, N3;
578:  *		vecCon MyvecCon;
579:  *		std::vector<int> result;
580:  *
581:  *		N1.setId(10);
582:  *		N2.setId(20);
583:  *		N3.setId(30);
584:  *
585:  *		Con1.setFromNeuron(&N1);
586:  *		Con2.setFromNeuron(&N2);
587:  *		Con3.setFromNeuron(&N3);
588:  *
589:  *		Con1.setWeight(1.01);
590:  *		Con2.setWeight(22.02);
591:  *		Con3.setWeight(333.03);
592:  *
593:  *	// Test
594:  *		result.push_back(MyvecCon.numOfCons());
595:  *		MyvecCon.push_back(Con1);
596:  *		result.push_back(MyvecCon.numOfCons());
597:  *		MyvecCon.push_back(Con2);
598:  *		result.push_back(MyvecCon.numOfCons());
599:  *		MyvecCon.push_back(Con3);
600:  *		result.push_back(MyvecCon.numOfCons());
601:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
602:  * \endcode
603:  *
604:  * \sa vecAMORE::size (alias)
605:  */
606: int  vecCon::numOfCons() {
607: 	return ldata.size();
608: }
609: 
610: 
611: 
612: //! Getter of the Id values of the vector of Cons
613: /*!
614:  * This function returns the Id's of the neurons referred to by the vector of Cons.
615:  * \return An std::vector<int> that contains the Ids
616:  *
617:  * \code
618:  *  //================
619:  *  //Usage example:
620:  *  //================
621:  * 	// Data set up
622:  *		Con Con1, Con2, Con3;
623:  *		Neuron N1, N2, N3;
624:  *		vecCon MyvecCon;
625:  *		std::vector<int> result;
626:  *
627:  *		N1.setId(10);
628:  *		N2.setId(20);
629:  *		N3.setId(30);
630: 
631:  *		Con1.setFromNeuron(&N1);
632:  *		Con2.setFromNeuron(&N2);
633:  *		Con3.setFromNeuron(&N3);
634:  *
635:  *		Con1.setWeight(1.01);
636:  *		Con2.setWeight(22.02);
637:  *		Con3.setWeight(333.03);
638: 
639:  *		MyvecCon.push_back(Con1);
640:  *		MyvecCon.push_back(Con2);
641:  *		MyvecCon.push_back(Con3);
642: 
643:  *		MyvecCon.show() ;
644:  *		MyvecCon.validate();
645:  *
646:  *	// Test
647:  *		result=MyvecCon.getFromId();
648:  *	// Now result is a vector that contains the values 10, 20 and 30.
649:  *
650:  * \endcode
651:  */
652: std::vector<int>  vecCon::getFromId() {
653: 	std::vector<int> result;
654: 	result.reserve(numOfCons());
655: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
656: 	return result;
657: }
658: 
659: 
660: 
661: //
662: //
663: //
664: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
665: //
666: //	BEGIN_RCPP
667: //	Con con;
668: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
669: //	ldata.reserve(ldata.size() + FROM.size());
670: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
671: //
672: //		new();
673: //
674: //		ldata.push_back(
675: //		)
676: //	}
677: //
678: //
679: //	END_RCPP
680: //}
681: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
682: 
683: 
684: 
685: /*
686:  *
687:  * 	initialize=function(con, ...){
688: 					if (missing(con)){
689: 						callSuper(...)
690: 					} else {
691: 						push_back(con)
692: 						return(.self)
693: 					}
694: 				},
695: 
696: 
697: 				getWeight = function(FROM, ...){
698: 					if (missing(FROM)) {
699: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
700: 					} else {
701: 						return(select(FROM)$getWeight(...))
702: 					}
703: 				},
704: 
705: 				getFrom = function(...){
706: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
707: 				},
708: 
709: 
710: 				setWeight= function(value, FROM, ...) {
711: 					value <- c(value, recursive=TRUE)
712: 					if (missing(FROM)) {
713: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
714: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
715: 					} else {
716: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
717: 						myMatch <- match(FROM, getFromId(...))
718: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
719: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
720: 					}
721: 				},
722: 
723: 				setFrom= function(value, FROM, ...) {
724: 					value <- c(value, recursive=TRUE)
725: 					if (missing(FROM)) {
726: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
727: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
728: 					} else {
729: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
730: 						myMatch <- match(FROM, getFromId(...))
731: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
732: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
733: 					}
734: 				},
735: 
736: 				delete = function(FROM, ...) {
737: 					fromIds <- getFromId(...)
738: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
739: 					if (length(delIds)>0) {
740: 						ldata <<- ldata[-delIds]
741: 					}
742: 				},
743: 
744: 				select=function(FROM, ...){
745: 					fromObject <- getFromId(...)
746: 					myMatch <- match(FROM,  fromObject)
747: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
748: 					idx <- seq(along=ldata) [- myMatch]
749: 					selfClone <- copy(shallow=FALSE)
750: 					selfClone$delete(FROM=fromObject[idx])
751: 					return(selfClone)
752: 				},
753: 
754: 				numOfCons=function(...) {
755: 					return(length(ldata))
756: 				},
757: 
758: 				validate=function(...){
759: 					'Object validator for internal coherence.
760: 							'
761: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
762: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
763: 					lapply(ldata, function(x){x$validate(...)})
764: 					return(TRUE)
765:  *
766:  *
767:  */
768:  /*
769:  * Neuron.cpp
770:  *
771:  *  Created on: 25/05/2011
772:  *      Author: mcasl
773:  */
774: 
775: #ifndef INLINE_R
776: 
777: #include "Neuron.h"
778: 
779: #endif /* INLINE_R */
780: 
781: 
782: int Neuron::getId() {
783: 	return Id;
784: }
785: 
786: void Neuron::setId(int id) {
787: 	Id=id;
788: }
789: 
790: 
791: 
792: 
793: 
794: 
795: 
796: 
797: // declarations
798: extern "C" {
799: SEXP file746043b0( ) ;
800: }
801: 
802: // definition
803: 
804: SEXP file746043b0(  ){
805: BEGIN_RCPP
806: 
807: 			// Data set up
808: 			Con Con1, Con2, Con3;
809: 			Neuron N1, N2, N3;
810: 			vecCon MyvecCon;
811: 			std::vector<int> result;
812: 			
813: 			N1.setId(10);
814: 			N2.setId(20);
815: 			N3.setId(30);
816: 			
817: 			Con1.setFromNeuron(&N1);
818: 			Con2.setFromNeuron(&N2);
819: 			Con3.setFromNeuron(&N3);
820: 			
821: 			Con1.setWeight(1.01);
822: 			Con2.setWeight(22.02);
823: 			Con3.setWeight(333.03);			
824: 			
825: 			// Test
826: 			result.push_back(MyvecCon.numOfCons());
827: 			MyvecCon.push_back(Con1);
828: 			result.push_back(MyvecCon.numOfCons());
829: 			MyvecCon.push_back(Con2);
830: 			result.push_back(MyvecCon.numOfCons());
831: 			MyvecCon.push_back(Con3);
832: 			result.push_back(MyvecCon.numOfCons());
833: 						
834: 			return wrap(result);
835: 			
836: END_RCPP
837: }
838: 
839: 
Timing stopped at: 1.914 0.348 2.877 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file746043b0.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file746043b0.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file746043b0.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file746043b0.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file746043b0.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file746043b0.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file746043b0.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file746043b0.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file746043b0.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file746043b0.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file746043b0.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file746043b0.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file746043b0.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file746043b0.cpp:485: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:84: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file746043b0.cpp:529: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:128: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file746043b0.cpp:541: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:140: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file746043b0.cpp:552: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:151: error: 'int vecAMORE<T>::size()' previously declared here
file746043b0.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file746043b0.cpp:655: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file746043b0.cpp:655: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file746043b0.cpp: At global scope:
file746043b0.cpp:782: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file746043b0.cpp:786: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file746043b0.cpp: In function 'SEXPREC* file746043b0()':
file746043b0.cpp:827: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file746043b0.cpp:829: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file746043b0.cpp:831: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file746043b0.o] Error 1
Adem'as: Mensajes de aviso perdidos
comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file746043b0.cpp 2> file746043b0.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.gCon.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gCon.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gCon.getWeight  ...  done successfully.



Executing test function test.gCon.new_fromIsNeuron  ...  done successfully.



Executing test function test.gCon.new_fromIsNumeric  ...  done successfully.



Executing test function test.gCon.setFrom  ...  done successfully.



Executing test function test.gCon.setWeight  ...  done successfully.



Executing test function test.gCon.show  ... 
 From:  1 	 Weight:  14.5 done successfully.



Executing test function test.gCon.validate  ...  done successfully.



Executing test function test.gMLPneuron.new  ...  done successfully.



Executing test function test.gMLPneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Bias:  9.9
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gMLPneuron.validate  ...  done successfully.



Executing test function test.gNeuron.addCon  ...  done successfully.



Executing test function test.gNeuron.deleteCon  ...  done successfully.



Executing test function test.gNeuron.getCon  ...  done successfully.



Executing test function test.gNeuron.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gNeuron.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gNeuron.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gNeuron.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gNeuron.getWeight  ...  done successfully.



Executing test function test.gNeuron.new  ...  done successfully.



Executing test function test.gNeuron.numOfCons  ...  done successfully.



Executing test function test.gNeuron.setCon  ...  done successfully.



Executing test function test.gNeuron.setFrom  ...  done successfully.



Executing test function test.gNeuron.setId.getId  ...  done successfully.



Executing test function test.gNeuron.setWeight  ...  done successfully.



Executing test function test.gNeuron.show  ... 
------------------------

 Id:  1
------------------------

 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------
 done successfully.



Executing test function test.gNeuron.validate  ...  done successfully.



Executing test function test.gRBFneuron.new  ... 
------------------------------
 Id:  1
-----------------
 Width:  9.9
-----------------
 Altitude:  29.3
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gRBFneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Width:  9.9
-----------------
 Altitude:  29.3
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------------ done successfully.



Executing test function test.gRBFneuron.validate  ...  done successfully.



Executing test function test.gListAMORE.append  ...  done successfully.



Executing test function test.gListAMORE.getLdata  ...  done successfully.



Executing test function test.gListAMORE.new  ...  done successfully.



Executing test function test.gListAMORE.push_back  ...  done successfully.



Executing test function test.gListAMORE.setLdata  ...  done successfully.



Executing test function test.gListAMORE.show  ... 
 From:  1 	 Weight:  14.5
 From:  2 	 Weight:  24.5
 From:  3 	 Weight:  34.5 done successfully.



Executing test function test.gListAMORE.validate  ...  done successfully.



Executing test function test.gListCon.delete  ...  done successfully.



Executing test function test.gListCon.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.getFrom_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.getWeight_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.getWeight_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.new  ...  done successfully.



Executing test function test.gListCon.numOfCons  ...  done successfully.



Executing test function test.gListCon.populate_fromIsNeuron  ...  done successfully.



Executing test function test.gListCon.populate_fromIsNumeric  ...  done successfully.



Executing test function test.gListCon.push_back  ...  done successfully.



Executing test function test.gListCon.select  ...  done successfully.



Executing test function test.gListCon.setFrom  ...  done successfully.



Executing test function test.gListCon.setWeight  ...  done successfully.



Executing test function test.gListCon.show  ... 
 From:  1 	 Weight:  10
 From:  2 	 Weight:  9
 From:  3 	 Weight:  8
 From:  4 	 Weight:  7
 From:  5 	 Weight:  6
 From:  6 	 Weight:  5
 From:  7 	 Weight:  4
 From:  8 	 Weight:  3
 From:  9 	 Weight:  2
 From:  10 	 Weight:  1 done successfully.



Executing test function test.gListCon.validate  ...  done successfully.



Executing test function test.gListLayer.delete  ...  done successfully.



Executing test function test.gListLayer.getId  ...  done successfully.



Executing test function test.gListLayer.new_fromIsNeuron  ...  done successfully.



Executing test function test.gListLayer.new_fromIsNumeric  ...  done successfully.



Executing test function test.gListLayer.numOfLayers  ...  done successfully.



Executing test function test.gListLayer.select  ...  done successfully.



Executing test function test.glistMLPlayer.validate  ...  done successfully.



Executing test function test.gListMLPneuron.new  ...  done successfully.



Executing test function test.gListMLPneuron.populate_fromIsNeuron  ...  done successfully.



Executing test function test.gListMLPneuron.populate_fromIsNumeric  ...  done successfully.



Executing test function test.gListMLPneuron.setBias.getBias  ...  done successfully.



Executing test function test.gListMLPneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Bias:  1.1
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
------------------------------
------------------------------
 Id:  2
-----------------
 Bias:  3.4
------------------------------
 From:  1 	 Weight:  21
 From:  2 	 Weight:  22
 From:  3 	 Weight:  23
------------------------------
------------------------------
 Id:  3
-----------------
 Bias:  5.4
------------------------------
 From:  1 	 Weight:  31
 From:  2 	 Weight:  32
 From:  3 	 Weight:  33
------------------------------
------------------------------
 Id:  4
-----------------
 Bias:  9.8
------------------------------
 From:  1 	 Weight:  41
 From:  2 	 Weight:  42
 From:  3 	 Weight:  43
------------------------------
------------------------------
 Id:  5
-----------------
 Bias:  5.6
------------------------------
 From:  1 	 Weight:  51
 From:  2 	 Weight:  52
 From:  3 	 Weight:  53
------------------------------ done successfully.



Executing test function test.gListMLPneuron.validate  ...  done successfully.



Executing test function test.gListNeuron.delete  ...  done successfully.



Executing test function test.gListNeuron.getFromId_fromIsNeuron  ...  done successfully.



Executing test function test.gListNeuron.getFromId_fromIsNumeric  ...  done successfully.



Executing test function test.gListNeuron.getFrom_fromIsNumeric  ...  done successfully.



Executing test function test.gListNeuron.is.regular  ...  done successfully.



Executing test function test.gListNeuron.new.push_back.numberOfNeurons.numOfCons  ...  done successfully.



Executing test function test.gListNeuron.select  ...  done successfully.



Executing test function test.gListNeuron.setFrom.getFrom  ...  done successfully.



Executing test function test.gListNeuron.setId.getId  ...  done successfully.



Executing test function test.gListNeuron.setWeight.getWeight  ...  done successfully.



Executing test function test.gListNeuron.show  ... 
------------------------

 Id:  1
------------------------

 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
 From:  4 	 Weight:  14
 From:  5 	 Weight:  15
------------------------

------------------------

 Id:  2
------------------------

 From:  1 	 Weight:  1
 From:  2 	 Weight:  2
 From:  3 	 Weight:  3
 From:  4 	 Weight:  4
 From:  5 	 Weight:  5
------------------------
 done successfully.



Executing test function test.gListNeuron.validate  ...  done successfully.



Executing test function test.gListRBFlayer.validate  ...  done successfully.



Executing test function test.gListRBFneuron.new  ...  done successfully.



Executing test function test.gListRBFneuron.populate  ...  done successfully.



Executing test function test.gListRBFneuron.setAltitude.getAltitude  ...  done successfully.



Executing test function test.gListRBFneuron.setWidth.getWidth  ...  done successfully.



Executing test function test.gListRBFneuron.show  ... 
------------------------------
 Id:  1
-----------------
 Width:  1.1
-----------------
 Altitude:  1.9
------------------------------
 From:  1 	 Weight:  11
 From:  2 	 Weight:  12
 From:  3 	 Weight:  13
------------------------------
------------------------------
 Id:  2
-----------------
 Width:  3.4
-----------------
 Altitude:  8.4
------------------------------
 From:  4 	 Weight:  21
 From:  5 	 Weight:  22
 From:  6 	 Weight:  23
------------------------------
------------------------------
 Id:  3
-----------------
 Width:  5.4
-----------------
 Altitude:  8.7
------------------------------
 From:  7 	 Weight:  31
 From:  8 	 Weight:  32
 From:  9 	 Weight:  33
------------------------------
------------------------------
 Id:  4
-----------------
 Width:  9.8
-----------------
 Altitude:  3.5
------------------------------
 From:  10 	 Weight:  41
 From:  11 	 Weight:  42
 From:  12 	 Weight:  43
------------------------------
------------------------------
 Id:  5
-----------------
 Width:  5.6
-----------------
 Altitude:  7.6
------------------------------
 From:  13 	 Weight:  51
 From:  14 	 Weight:  52
 From:  15 	 Weight:  53
------------------------------ done successfully.



Executing test function test.gListRBFneuron.validate  ...  done successfully.



Executing test function test.gmlpLayer.append  ...  done successfully.



Executing test function test.gmlpLayer.delete  ...  done successfully.



Executing test function test.gmlpLayer.is.regular  ...  done successfully.



Executing test function test.gmlpLayer.new  ...  done successfully.



Executing test function test.gmlpLayer.numOfCons  ...  done successfully.



Executing test function test.gmlpLayer.setAndGetWeight  ...  done successfully.



Executing test function test.gmlpLayer.setFrom.getFrom  ...  done successfully.



Executing test function test.gmlpLayer.setId.getId  ...  done successfully.



Executing test function test.gmlpLayer.validate  ...  done successfully.



Executing test function test.grbfLayer.append  ...  done successfully.



Executing test function test.grbfLayer.delete  ...  done successfully.



Executing test function test.grbfLayer.is.regular  ...  done successfully.



Executing test function test.grbfLayer.new  ...  done successfully.



Executing test function test.grbfLayer.numOfCons  ...  done successfully.



Executing test function test.grbfLayer.setFrom.getFrom  ...  done successfully.



Executing test function test.grbfLayer.setId.getId  ...  done successfully.



Executing test function test.grbfLayer.setWeight.getWeight  ...  done successfully.



Executing test function test.grbfLayer.validate  ...  done successfully.

Mensajes de aviso perdidos
1: In asMethod(object) : NAs introducidos por coerci'on
2: In asMethod(object) : NAs introducidos por coerci'on
3: In asMethod(object) : NAs introducidos por coerci'on
4: In asMethod(object) : NAs introducidos por coerci'on
5: In asMethod(object) : NAs introducidos por coerci'on
6: In class(value) <- "integer" : NAs introducidos por coerci'on
> 
> 
> 
> source("pkg/AMORE/unitTest/unitTestSuite.R")


Executing test function test.Con.Cpp.getFromId  ...  done successfully.



Executing test function test.Con.Cpp.setFromNeuron.getFromNeuron  ...  done successfully.



Executing test function test.Con.Cpp.setWeight.getWeight  ...  done successfully.



Executing test function test.Con.Cpp.show  ... From:	 16 	 Weight= 	 12.400000 
 done successfully.



Executing test function test.Con.Cpp.validate.from  ...  done successfully.



Executing test function test.Con.Cpp.validate.weight  ... file54740bbb.cpp: In function 'SEXPREC* file54740bbb()':
file54740bbb.cpp:60: warning: division by zero in '1.24000000000000003552713678800500929355621337890625e+1 / 0'
 done successfully.



Executing test function test.vecAMORE.Cpp.append  ... From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
From:	 40 	 Weight= 	 1.130000 
From:	 50 	 Weight= 	 2.220000 
From:	 60 	 Weight= 	 3.330000 
 done successfully.



Executing test function test.vecAMORE.Cpp.push_back  ...  done successfully.



Executing test function test.vecAMORE.Cpp.setLdata.getLdata  ...  done successfully.



Executing test function test.vecAMORE.Cpp.size  ...  done successfully.



Executing test function test.vecAMORE.Cpp.validate.show  ... From:	 10 	 Weight= 	 1.130000 
From:	 20 	 Weight= 	 2.220000 
From:	 30 	 Weight= 	 3.330000 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.getFromId.show  ... file19865073.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file19865073.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file19865073.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file19865073.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file19865073.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file19865073.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file19865073.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file19865073.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file19865073.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file19865073.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file19865073.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file19865073.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file19865073.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file19865073.cpp:534: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:133: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file19865073.cpp:578: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:177: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file19865073.cpp:590: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:189: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file19865073.cpp:601: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:200: error: 'int vecAMORE<T>::size()' previously declared here
file19865073.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file19865073.cpp:704: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file19865073.cpp:704: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file19865073.cpp: At global scope:
file19865073.cpp:831: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file19865073.cpp:835: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file19865073.cpp: In function 'SEXPREC* file19865073()':
file19865073.cpp:873: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file19865073.cpp:874: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file19865073.cpp:875: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file19865073.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  *
485:  *
486:  * \code
487:  *	//================
488:  *	//Usage example:
489:  *	//================
490:  *
491:  * 	// Data set up
492:  *		Neuron N1, N2, N3, N4, N5, N6;
493:  *		vecAMORE<Con> vcA, vcB;
494:  *		std::vector<int> result;
495:  *
496:  *		N1.setId(10);
497:  *		N2.setId(20);
498:  *		N3.setId(30);
499:  *		N4.setId(40);
500:  *		N5.setId(50);
501:  *		N6.setId(60);
502:  *
503:  *	// Test
504:  *		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons
505:  *		vcA.push_back(ptCon);
506:  *		ptCon.reset( new Con(&N2, 2.22) );
507:  *		vcA.push_back(ptCon);
508:  *		ptCon.reset(  new Con(&N3, 3.33) );
509:  *		vcA.push_back(ptCon);
510:  *
511:  *		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
512:  *		vcB.push_back(ptCon);
513:  *		ptCon.reset( new Con(&N5, 2.22) );
514:  *		vcB.push_back(ptCon);
515:  *		ptCon.reset(  new Con(&N6, 3.33) );
516:  *		vcB.push_back(ptCon);
517:  *
518:  *	// Append test
519:  *		vcA.append(vcB);
520:  *		vcA.validate();
521:  *		vcA.show() ;
522:  *
523:  *	// After execution of the code above, the output at the R terminal would display:
524:  *	// From:	 10 	 Weight= 	 1.130000
525:  *	// From:	 20 	 Weight= 	 2.220000
526:  *	// From:	 30 	 Weight= 	 3.330000
527:  *	// From:	 40 	 Weight= 	 1.130000
528:  *	// From:	 50 	 Weight= 	 2.220000
529:  *	// From:	 60 	 Weight= 	 3.330000
530:  * \endcode
531:  *
532:  * \sa vecAMORE::setLdata , vecAMORE::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
533:  */
534: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
535: 	ldata.reserve(ldata.size() + v.size());
536: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
537: };
538: 
539: 
540: //! %ldata field accessor function
541: /*!
542:  *  This method allows access to the data stored in the \ref ldata field.
543:  * \return The ldata vector.
544:  *
545:  * \code
546:  * 	//================
547:  *	//Usage example:
548:  *	//================
549:  *		// Data set up
550:  *			Neuron N1, N2, N3;
551:  *			vecAMORE<Con> MyvecCon;
552:  *			std::vector<int> result;
553:  *			std::vector<ConSharedPtr> vcA, vcB;
554:  *
555:  *			N1.setId(10);
556:  *			N2.setId(20);
557:  *			N3.setId(30);
558:  *
559:  *		// Test
560:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
561:  *			vcA.push_back(ptCon);						// push_back
562:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
563:  *			vcA.push_back(ptCon);						// push_back
564:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
565:  *			vcA.push_back(ptCon);						// push_back
566:  *
567:  *			MyvecCon.setLdata(vcA);
568:  *			vcB = MyvecCon.getLdata();
569:  *
570:  *			result.push_back(vcB.at(0)->getFromId());
571:  *			result.push_back(vcB.at(1)->getFromId());
572:  *			result.push_back(vcB.at(2)->getFromId());
573:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
574:  * \endcode
575:  *
576:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
577:  */
578: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
579: 	return ldata;
580: };
581: 
582: 
583: 
584: //! %ldata field accessor function
585: /*!
586:  *  This method sets the value of the data stored in the \ref ldata field.
587:  * \param v The vector of smart pointers to be stored in the ldata field
588:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
589:  */
590: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
591: 	ldata=v;
592: };
593: 
594: 
595: //! Returns the size or length of the vector
596: /*!
597:  *  This method returns the size of the vector.
598:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
599:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
600:  */
601: template <typename T> int vecAMORE<T>::size() {
602: 	return ldata.size() ;
603: };
604: 
605:  /*
606:  * vecCon.cpp
607:  *
608:  *  Created on: 26/05/2011
609:  *      Author: mcasl
610:  */
611: 
612: 
613: 
614: 
615: //! Size of the vecCon object
616: /*!
617:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
618:  * \return The size of the vector
619:  *
620:  *  \code
621:  *  //================
622:  *  //Usage example:
623:  *  //================
624:  * 	// Data set up
625:  *		Con Con1, Con2, Con3;
626:  *		Neuron N1, N2, N3;
627:  *		vecCon MyvecCon;
628:  *		std::vector<int> result;
629:  *
630:  *		N1.setId(10);
631:  *		N2.setId(20);
632:  *		N3.setId(30);
633:  *
634:  *		Con1.setFromNeuron(&N1);
635:  *		Con2.setFromNeuron(&N2);
636:  *		Con3.setFromNeuron(&N3);
637:  *
638:  *		Con1.setWeight(1.01);
639:  *		Con2.setWeight(22.02);
640:  *		Con3.setWeight(333.03);
641:  *
642:  *	// Test
643:  *		result.push_back(MyvecCon.numOfCons());
644:  *		MyvecCon.push_back(Con1);
645:  *		result.push_back(MyvecCon.numOfCons());
646:  *		MyvecCon.push_back(Con2);
647:  *		result.push_back(MyvecCon.numOfCons());
648:  *		MyvecCon.push_back(Con3);
649:  *		result.push_back(MyvecCon.numOfCons());
650:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
651:  * \endcode
652:  *
653:  * \sa vecAMORE::size (alias)
654:  */
655: int  vecCon::numOfCons() {
656: 	return ldata.size();
657: }
658: 
659: 
660: 
661: //! Getter of the Id values of the vector of Cons
662: /*!
663:  * This function returns the Id's of the neurons referred to by the vector of Cons.
664:  * \return An std::vector<int> that contains the Ids
665:  *
666:  * \code
667:  *  //================
668:  *  //Usage example:
669:  *  //================
670:  * 	// Data set up
671:  *		Con Con1, Con2, Con3;
672:  *		Neuron N1, N2, N3;
673:  *		vecCon MyvecCon;
674:  *		std::vector<int> result;
675:  *
676:  *		N1.setId(10);
677:  *		N2.setId(20);
678:  *		N3.setId(30);
679: 
680:  *		Con1.setFromNeuron(&N1);
681:  *		Con2.setFromNeuron(&N2);
682:  *		Con3.setFromNeuron(&N3);
683:  *
684:  *		Con1.setWeight(1.01);
685:  *		Con2.setWeight(22.02);
686:  *		Con3.setWeight(333.03);
687: 
688:  *		MyvecCon.push_back(Con1);
689:  *		MyvecCon.push_back(Con2);
690:  *		MyvecCon.push_back(Con3);
691: 
692:  *		MyvecCon.show() ;
693:  *		MyvecCon.validate();
694:  *
695:  *	// Test
696:  *		result=MyvecCon.getFromId();
697:  *	// Now result is a vector that contains the values 10, 20 and 30.
698:  *
699:  * \endcode
700:  */
701: std::vector<int>  vecCon::getFromId() {
702: 	std::vector<int> result;
703: 	result.reserve(numOfCons());
704: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
705: 	return result;
706: }
707: 
708: 
709: 
710: //
711: //
712: //
713: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
714: //
715: //	BEGIN_RCPP
716: //	Con con;
717: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
718: //	ldata.reserve(ldata.size() + FROM.size());
719: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
720: //
721: //		new();
722: //
723: //		ldata.push_back(
724: //		)
725: //	}
726: //
727: //
728: //	END_RCPP
729: //}
730: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
731: 
732: 
733: 
734: /*
735:  *
736:  * 	initialize=function(con, ...){
737: 					if (missing(con)){
738: 						callSuper(...)
739: 					} else {
740: 						push_back(con)
741: 						return(.self)
742: 					}
743: 				},
744: 
745: 
746: 				getWeight = function(FROM, ...){
747: 					if (missing(FROM)) {
748: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
749: 					} else {
750: 						return(select(FROM)$getWeight(...))
751: 					}
752: 				},
753: 
754: 				getFrom = function(...){
755: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
756: 				},
757: 
758: 
759: 				setWeight= function(value, FROM, ...) {
760: 					value <- c(value, recursive=TRUE)
761: 					if (missing(FROM)) {
762: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
763: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
764: 					} else {
765: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
766: 						myMatch <- match(FROM, getFromId(...))
767: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
768: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
769: 					}
770: 				},
771: 
772: 				setFrom= function(value, FROM, ...) {
773: 					value <- c(value, recursive=TRUE)
774: 					if (missing(FROM)) {
775: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
776: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
777: 					} else {
778: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
779: 						myMatch <- match(FROM, getFromId(...))
780: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
781: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
782: 					}
783: 				},
784: 
785: 				delete = function(FROM, ...) {
786: 					fromIds <- getFromId(...)
787: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
788: 					if (length(delIds)>0) {
789: 						ldata <<- ldata[-delIds]
790: 					}
791: 				},
792: 
793: 				select=function(FROM, ...){
794: 					fromObject <- getFromId(...)
795: 					myMatch <- match(FROM,  fromObject)
796: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
797: 					idx <- seq(along=ldata) [- myMatch]
798: 					selfClone <- copy(shallow=FALSE)
799: 					selfClone$delete(FROM=fromObject[idx])
800: 					return(selfClone)
801: 				},
802: 
803: 				numOfCons=function(...) {
804: 					return(length(ldata))
805: 				},
806: 
807: 				validate=function(...){
808: 					'Object validator for internal coherence.
809: 							'
810: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
811: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
812: 					lapply(ldata, function(x){x$validate(...)})
813: 					return(TRUE)
814:  *
815:  *
816:  */
817:  /*
818:  * Neuron.cpp
819:  *
820:  *  Created on: 25/05/2011
821:  *      Author: mcasl
822:  */
823: 
824: #ifndef INLINE_R
825: 
826: #include "Neuron.h"
827: 
828: #endif /* INLINE_R */
829: 
830: 
831: int Neuron::getId() {
832: 	return Id;
833: }
834: 
835: void Neuron::setId(int id) {
836: 	Id=id;
837: }
838: 
839: 
840: 
841: 
842: 
843: 
844: 
845: 
846: // declarations
847: extern "C" {
848: SEXP file19865073( ) ;
849: }
850: 
851: // definition
852: 
853: SEXP file19865073(  ){
854: BEGIN_RCPP
855: 
856: 		Con Con1, Con2, Con3;
857: 		Neuron N1, N2, N3;
858: 		vecCon MyvecCon;
859: 		std::vector<int> result;
860: 		
861: 		N1.setId(10);
862: 		N2.setId(20);
863: 		N3.setId(30);
864: 		
865: 		Con1.setFromNeuron(&N1);
866: 		Con2.setFromNeuron(&N2);
867: 		Con3.setFromNeuron(&N3);
868: 		
869: 		Con1.setWeight(1.01);
870: 		Con2.setWeight(22.02);
871: 		Con3.setWeight(333.03);			
872: 		
873: 		MyvecCon.push_back(Con1);
874: 		MyvecCon.push_back(Con2);
875: 		MyvecCon.push_back(Con3);
876: 		
877: 		MyvecCon.show() ;
878: 		MyvecCon.validate();
879: 		result=MyvecCon.getFromId();
880: 		
881: 		return wrap(result);
882: 		
883: 		
884: END_RCPP
885: }
886: 
887: 
Timing stopped at: 1.922 0.354 2.456 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file19865073.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file19865073.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file19865073.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file19865073.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file19865073.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file19865073.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file19865073.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file19865073.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file19865073.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file19865073.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file19865073.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file19865073.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file19865073.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file19865073.cpp:534: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:133: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file19865073.cpp:578: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:177: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file19865073.cpp:590: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:189: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file19865073.cpp:601: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:200: error: 'int vecAMORE<T>::size()' previously declared here
file19865073.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file19865073.cpp:704: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file19865073.cpp:704: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file19865073.cpp: At global scope:
file19865073.cpp:831: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file19865073.cpp:835: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file19865073.cpp: In function 'SEXPREC* file19865073()':
file19865073.cpp:873: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file19865073.cpp:874: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file19865073.cpp:875: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file19865073.o] Error 1
Adem'as: Mensajes de aviso perdidos
1: In isValidTestSuite(testSuites) :
  'testSuite' object is not of class 'RUnitTestSuite'.
2: comando ejecutado '/Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file19865073.cpp 2> file19865073.cpp.err.txt' tiene estatus 1 
 done successfully.



Executing test function test.vecCon.Cpp.push_back.numOfCons  ... file410bbb1c.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file410bbb1c.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file410bbb1c.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file410bbb1c.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file410bbb1c.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file410bbb1c.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file410bbb1c.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file410bbb1c.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file410bbb1c.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file410bbb1c.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file410bbb1c.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file410bbb1c.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file410bbb1c.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file410bbb1c.cpp:534: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:133: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file410bbb1c.cpp:578: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:177: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file410bbb1c.cpp:590: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:189: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file410bbb1c.cpp:601: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:200: error: 'int vecAMORE<T>::size()' previously declared here
file410bbb1c.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file410bbb1c.cpp:704: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__gnu_cxx::__normal_iterator<Con*, std::vector<Con, std::allocator<Con> > >' requested
file410bbb1c.cpp:704: error: no match for 'operator!=' in 'itr != ((vecCon*)this)->vecCon::<anonymous>.vecAMORE<Con>::ldata. std::vector<_Tp, _Alloc>::end [with _Tp = boost::shared_ptr<Con>, _Alloc = std::allocator<boost::shared_ptr<Con> >]()'
file410bbb1c.cpp: At global scope:
file410bbb1c.cpp:831: error: redefinition of 'int Neuron::getId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:15: error: 'int Neuron::getId()' previously defined here
file410bbb1c.cpp:835: error: redefinition of 'void Neuron::setId(int)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Neuron.cpp:19: error: 'void Neuron::setId(int)' previously defined here
file410bbb1c.cpp: In function 'SEXPREC* file410bbb1c()':
file410bbb1c.cpp:876: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file410bbb1c.cpp:878: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
file410bbb1c.cpp:880: error: no matching function for call to 'vecCon::push_back(Con&)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: note: candidates are: void vecAMORE<T>::push_back(boost::shared_ptr<X>) [with T = Con]
make: *** [file410bbb1c.o] Error 1

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: #include <Rcpp.h>
  5: 
  6: 
  7: #ifndef BEGIN_RCPP
  8: #define BEGIN_RCPP
  9: #endif
 10: 
 11: #ifndef END_RCPP
 12: #define END_RCPP
 13: #endif
 14: 
 15: using namespace Rcpp;
 16: 
 17: 
 18: // user includes
 19: #define INLINE_R
 20:  /*! \mainpage The AMORE++ package
 21:  *
 22:  * \section intro_sec Introduction
 23:  *
 24:  * Here you will find the documentation of the C++ component of the AMORE++ R package.
 25:  * The AMORE++ package is a new version of the publicly available AMORE package for neural network training and simulation under R
 26:  *
 27:  * \section motiv_sec Motivation
 28:  *
 29:  * Since the release of the previous version of the AMORE many things have changed in the R programming world.
 30:  * The advent of the Reference Classes and of packages like Rcpp, inline and RUnit compel us to write a better version of the package in order to provide a more useful framework for neural network training and simulation.
 31:  *
 32:  * \section RoadMap Road Map
 33:  * This project is currently very active and the development team intends to provide a beta version as soon as this summer (2011)
 34:  *
 35:  */
 36: 
 37: 
 38: #include <iostream>
 39: #include <sstream>
 40: #include <algorithm>
 41: #include <vector>
 42: #include <boost/shared_ptr.hpp>
 43: #include <Rcpp.h>
 44: 
 45: using namespace Rcpp;
 46: 
 47: class Con;
 48: template <typename T> class vecAMORE;
 49: //class vecCon;
 50: class Neuron;
 51: 
 52: 
 53: #include "Con.h"
 54: 
 55: 
 56: 
 57: #include "vecAMORE.h"
 58: //#include "vecCon.h"
 59: #include "Neuron.h"
 60: 
 61: 
 62: #include "Con.cpp"
 63: #include "vecAMORE.cpp"
 64: //#include "vecCon.cpp"
 65: #include "Neuron.cpp"
 66:  /*
 67:  * Con.h
 68:  *
 69:  *  Created on: 25/05/2011
 70:  *      Author: mcasl
 71:  */
 72: 
 73: #ifndef CON_H_
 74: #define CON_H_
 75: 
 76: //!  A class to handle the information needed to describe an input connection.
 77: /*!
 78:  *   The Con class provides a simple class for a connection described by a pair of values: a pointer to the Neuron used as the \ref from field and the \ref weight used to propagate the value of that Neuron object.
 79:  */
 80: 
 81: class Con {
 82: 	//! A pointer to the Neuron used as input during simulation or training.
 83: 	/*!
 84: 	 * The \ref from field contains the address of the Neuron whose output will be used as input by the Neuron containing the Con object.
 85: 	 */
 86: 	Neuron* from;
 87: 	//! A double variable that contains the weight of the connection
 88: 	/*!
 89: 	 * The \ref weight field contains the factor by which the output value of the Neuron addressed by the from field is multiplied during simulation or training.
 90: 	 */
 91: 	double weight;
 92: 
 93: public:
 94: 
 95: 	Con();
 96: 	Con(Neuron* f , double w );
 97: 	~Con();
 98: 	Neuron*		getFromNeuron	();
 99: 	void 		setFromNeuron	(Neuron* f);
100: 	int			getFromId		();
101: 	double 		getWeight		();
102: 	void 		setWeight		(double w);
103: 	bool		show			();
104: 	bool		validate		();
105: };
106: #endif /* CON_H_ */
107: 
108: 
109: typedef boost::shared_ptr<Con> ConSharedPtr;
110:  /*
111:  * vecAMORE.h
112:  *
113:  *  Created on: 26/05/2011
114:  *      Author: mcasl
115:  */
116: 
117: 
118: #ifndef VECAMORE_H_
119: #define VECAMORE_H_
120: 
121: template <typename T> class vecAMORE {
122: protected:
123: 		std::vector<boost::shared_ptr<T> > ldata; // Don't forget the space between "> >"
124: 
125: public:
126: 		typename std::vector< boost::shared_ptr<T> > getLdata	();
127: 											void	setLdata	( typename  std::vector< boost::shared_ptr<T> > );
128: 											int 	size		();
129: 											void 	push_back	( boost::shared_ptr<T>   element);
130: 											void 	append		( vecAMORE<T>  v);
131: 											bool 	show		();
132: 											bool 	validate	();
133: };
134: 
135: 
136: #endif /* VECAMORE_H_ */ /*
137:  * vecCon.h
138:  *
139:  *  Created on: 26/05/2011
140:  *      Author: mcasl
141:  */
142: 
143: #ifndef VECCON_H_
144: #define VECCON_H_
145: 
146: 
147: //!  A vector of connections
148: /*!
149:  *   The vecCon class provides a simple class for a vector of connections. It's named after the R equivalent Reference Class.
150:  */
151: 
152: class vecCon: public vecAMORE<Con> {
153: 
154: public:
155: 
156: 	int					numOfCons();
157: 	std::vector<int>	getFromId();
158: 	//	void 				populate	( listNeuron * FROM, std::vector<double> WEIGHT);
159: 	//	std::vector<double>	getWeight	(FROM);
160: 	//
161: 	//						getFrom ();
162: 	//						setWeight(value, FROM);
163: 	//						setFrom(value, FROM);
164: 	//						delete(FROM);
165: 	//						select(FROM);
166: 	//						validate();
167: };
168: 
169: 
170: #endif /* VECCON_H_ */
171: 
172:  /*
173:  * Neuron.h
174:  *
175:  *  Created on: 25/05/2011
176:  *      Author: mcasl
177:  */
178: 
179: #ifndef NEURON_H_
180: #define NEURON_H_
181: 
182: //!  A class to handle the information contained in a general Neuron.
183: /*!
184:  *   A general class for neurons. The MLPneuron and RBFneuron classes will specialize this general class
185:  */
186: 
187: class Neuron {
188: 	//! An integer variable with the Neuron Id
189: 	/*!
190: 	 * The Neuron Id provides a name to the neuron. This value is not expected to be used neither during simulation nor training but it provides an easy reference for human readers.
191: 	 */
192: 	int Id;
193: 
194: 	//! A vector of input connections
195: 	/*!
196: 	 *
197: 	 */
198: 
199: 	//! \todo restore vecCon<Con> listCon;
200: 	// Con vecCon;
201: 	double outputValue;
202: public:
203: 
204: 	int  getId	();
205: 	void setId	(int id);
206: };
207: 
208: 
209: 
210: #endif /* NEURON_H_ */ /*
211:  * Con.cpp
212:  *
213:  *  Created on: 25/05/2011
214:  *      Author: mcasl
215:  */
216: 
217: #include "Con.h"
218: 
219: 
220: //=========================================================================================================
221: 
222: 
223: //! Default Constructor
224: /*
225:  * Default constructor, from=NULL, weight=0
226:  */
227: 	Con::Con() : from(NULL), weight(0) {};
228: 
229: 
230: //! Constructor
231: /*
232:  * Constructor, from=f, weight=w
233:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
234:  * \param w The new value (double) to be set in the \ref weight field.
235:  */
236: 	Con::Con(Neuron* f , double w ) : from(f), weight(w) {};
237: 
238: 
239: 
240: //! Default Destructor
241: 	Con::~Con() {};
242: 
243: 
244: 
245: //! %from field accessor.
246: /*! This method allows access to the address stored in the private \ref from field (a pointer to a Neuron object).*
247:  * \return A pointer to the Neuron object referred to by the \ref from field.
248:  *
249:  *  \code
250:  *	//================
251:  *	//Usage example:
252:  *	//================
253:  *	// Data set up
254:  *		Con myCon;
255:  *		Neuron MyNeuron;
256:  *		Neuron* ptNeuron;
257:  *		MyNeuron.setId(1);
258:  *		myCon.setFromNeuron(&MyNeuron);
259:  *
260:  *	//Test
261:  *		ptNeuron = myCon.getFromNeuron();
262:  *		int result= ptNeuron->getId();
263:  *	// Now, ptNeuron is pointing at MyNeuron and, thus, result is equal to 1.
264:  * \endcode
265:  *
266:  * \sa getFromId and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
267:  */
268: Neuron* Con::getFromNeuron	()   			{
269: 	return(from);
270: }
271: 
272: 
273: 
274: //! %from field accessor.
275: /*! This method sets the value of the \ref from field with the address used as parameter.
276:  * \param f A pointer to the neuron that is to be inserted in the \ref from field.
277:  * \sa getFromNeuron and getFromId contain usage examples. For further examples see the unit test files, e.g., runit.Cpp.Con.R
278:  */
279: void Con::setFromNeuron	(Neuron* f)   	{
280: 	from = f;
281: }
282: 
283: 
284: 
285: //! A getter of the Id of the Neuron pointed by the from field.
286: /*! This method gets the Id of the Neuron referred to by the \ref from field
287:  * \return The value of the Id (an integer).
288:  *
289:  *  \code
290:  *	//================
291:  *	//Usage example:
292:  *	//================
293:  *	// Data set up
294:  *		Con myCon;
295:  *		Neuron MyNeuron;
296:  *		MyNeuron.setId(16);
297:  *		myCon.setFromNeuron(&MyNeuron);
298:  *
299:  *	// Test
300:  * 		int result= myCon.getFromId();
301:  *	// After execution of the code shown above, MyNeuron::Id is set to the integer value 16 and, thus, result is equal to 16.
302:  * \endcode
303:  *
304:  * \sa getFromNeuron, setFromNeuron and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
305:  */
306: int Con::getFromId () {
307: 	return(from->getId() );
308: }
309: 
310: 
311: 
312: 
313: //! %weight field accessor.
314: /*! This method allows access to the value stored in the private field \ref weight
315:  * \return The value of \ref weight (double)
316:  *
317:  *  \code
318:  *	//================
319:  *	//Usage example:
320:  *	//================
321:  *	// Data set up
322:  *		Con myCon;
323:  *		Neuron MyNeuron;
324:  *		MyNeuron.setId(16);
325:  *		myCon.setFromNeuron(&MyNeuron);
326:  *		myCon.setWeight(12.4);
327:  *		double result1= myCon.getWeight();
328:  *	// Test
329:  *		myCon.setWeight(2.2);
330:  *		double result2= myCon.getWeight();
331:  *	// Now, result1 is equal to 12.4 and result2 is equal to 2.2.
332:  * \endcode
333:  *
334:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for further examples.
335:  */
336: double Con::getWeight () {
337: 	return(weight);
338: }
339: 
340: 
341: 
342: 
343: //! %weight field accessor.
344: /*! This method sets the value of the \ref weight field.
345:  * \param w The new value (double) to be set in the \ref weight field.
346:  *
347:  * \code
348:  *  //================
349:  *  //Usage example:
350:  *  //================
351:  *  // Data set up
352:  *		Con myCon;
353:  *		Neuron n;
354:  *		n.setId(16);
355:  *		myCon.setFromNeuron(&n);
356:  *
357:  *	// Test
358:  *		myCon.setWeight(12.4);
359:  *		myCon.show();
360:  *	// Now, the output at the R terminal would show:
361:  *	//
362:  *	//  FROM=16		WEIGHT=12.4
363:  *	//
364:  * \endcode
365:  *
366:  * \sa getWeight and the unit test files (e.g. runit.Cpp.Con.R)
367:  */
368: void Con::setWeight	(double w) {
369: 	weight = w;
370: }
371: 
372: 
373: 
374: 
375: //! Pretty print of the Con information
376: /*! This method outputs in the R terminal the contents of the Con fields.
377:  * \return true in case everything works without throwing an exception
378:  * \sa setWeight and the unit test files, e.g., runit.Cpp.Con.R, for usage examples.
379:  */
380: bool Con::show () {
381: 	Rprintf("From:\t %d \t Weight= \t %lf \n", getFromId() , getWeight());
382: 	return(true);
383: }
384: 
385: 
386: 
387: 
388: //! Object validator
389: /*! This method checks the object for internal coherence.
390:  *  A try / catch mechanism exits normal execution and returns control to the R terminal in case the contents of the Con object are identified as corrupted.
391:  * \return true in case the checks are Ok.
392:  * \throw An std::range error if weight or from are not finite.
393:  */
394: bool Con::validate () {
395: 	BEGIN_RCPP
396: 	if (! R_FINITE(getWeight()) )  		throw std::range_error("weight is not finite.");
397: 	if (getFromId() == NA_INTEGER )		throw std::range_error("fromId is not finite.");
398: 	return(true);
399: 	END_RCPP
400: };
401: 
402:  /*
403:  * vecAMORE.cpp
404:  *
405:  *  Created on: 26/05/2011
406:  *      Author: mcasl
407:  */
408: 
409: 
410: //! Append a shared_ptr at the end of ldata
411: /*!
412:  * Implements push_back for the vecAMORE class
413:  * \param TsharedPtr A shared_ptr pointer to be inserted at the end of ldata
414:  *
415:  * \code
416:  *		//================
417:  *		//Usage example:
418:  *		//================
419:  *		// Data set up
420:  *			Neuron N1, N2, N3;
421:  *			vecAMORE<Con> MyvecCon;
422:  *			std::vector<ConSharedPtr> vc;
423:  *			std::vector<int> result;
424:  *			N1.setId(10);
425:  *			N2.setId(20);
426:  *			N3.setId(30);
427:  *		// Test
428:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
429:  *			MyvecCon.push_back(ptCon);				// push_back
430:  *			ptCon.reset(  new Con(&N2, 2.22) );		// create new Con and assign to ptCon
431:  *			MyvecCon.push_back(ptCon);				// push_back
432:  *			ptCon.reset(  new Con(&N3, 3.33) );		// create new Con and assign to ptCon
433:  *			MyvecCon.push_back(ptCon);				// push_back
434:  *
435:  *			vc = MyvecCon.getLdata();
436:  *
437:  *			result.push_back(vc.at(0)->getFromId());
438:  * 			result.push_back(vc.at(1)->getFromId());
439:  *			result.push_back(vc.at(2)->getFromId());
440:  * \endcode
441:  *
442:  * After execution of this code, result contains a numeric vector with values 10, 20 and 30.
443:  *
444:  * \sa C++ documentation for std::vector::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
445:  */
446: template <typename T> void vecAMORE<T>::push_back( boost::shared_ptr<T> TsharedPtr) {
447: 	this->ldata.push_back(TsharedPtr);
448: };
449: 
450: 
451: 
452: //! Pretty print of the vecAMORE<T>
453: /*! This method outputs in the R terminal the contents of vecAMORE::ldata.
454:  * \return true in case everything works without throwing an exception
455:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
456:  */
457: template <typename T> bool vecAMORE<T>::show() {
458: 	// This is equivalent to:
459: 	// for( auto x : ldata)	{ x.show(); }
460: 	// Waiting for C++0x
461: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->show(); }
462: 	return true;
463: };
464: 
465: 
466: 
467: //! Object validator
468: /*! This method checks the object for internal coherence.
469:  *  This method calls the validate method for each element in ldata,
470:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
471:  */
472: template <typename T> bool vecAMORE<T>::validate() {
473: 	for(typename std::vector< boost::shared_ptr<T>  >::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ (*itr)->validate(); }
474: 	return true;
475: };
476: 
477: 
478: 
479: //! Appends a vecAMORE<T> object
480: /*!
481:  * This method inserts the ldata field of a second object at the end of the ldata field of the calling object.
482:  * \param v The vecAMORE<T> object to be added to the current one
483:  * \sa The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
484:  *
485:  *
486:  * \code
487:  *	//================
488:  *	//Usage example:
489:  *	//================
490:  *
491:  * 	// Data set up
492:  *		Neuron N1, N2, N3, N4, N5, N6;
493:  *		vecAMORE<Con> vcA, vcB;
494:  *		std::vector<int> result;
495:  *
496:  *		N1.setId(10);
497:  *		N2.setId(20);
498:  *		N3.setId(30);
499:  *		N4.setId(40);
500:  *		N5.setId(50);
501:  *		N6.setId(60);
502:  *
503:  *	// Test
504:  *		ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create and store in vcA three Cons
505:  *		vcA.push_back(ptCon);
506:  *		ptCon.reset( new Con(&N2, 2.22) );
507:  *		vcA.push_back(ptCon);
508:  *		ptCon.reset(  new Con(&N3, 3.33) );
509:  *		vcA.push_back(ptCon);
510:  *
511:  *		ptCon.reset( new Con(&N4, 1.13) );  	// Create and store in vcB three more Cons
512:  *		vcB.push_back(ptCon);
513:  *		ptCon.reset( new Con(&N5, 2.22) );
514:  *		vcB.push_back(ptCon);
515:  *		ptCon.reset(  new Con(&N6, 3.33) );
516:  *		vcB.push_back(ptCon);
517:  *
518:  *	// Append test
519:  *		vcA.append(vcB);
520:  *		vcA.validate();
521:  *		vcA.show() ;
522:  *
523:  *	// After execution of the code above, the output at the R terminal would display:
524:  *	// From:	 10 	 Weight= 	 1.130000
525:  *	// From:	 20 	 Weight= 	 2.220000
526:  *	// From:	 30 	 Weight= 	 3.330000
527:  *	// From:	 40 	 Weight= 	 1.130000
528:  *	// From:	 50 	 Weight= 	 2.220000
529:  *	// From:	 60 	 Weight= 	 3.330000
530:  * \endcode
531:  *
532:  * \sa vecAMORE::setLdata , vecAMORE::push_back and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
533:  */
534: template <typename T> void vecAMORE<T>::append( vecAMORE<T> v) {
535: 	ldata.reserve(ldata.size() + v.size());
536: 	ldata.insert( ldata.end(), v.ldata.begin(), v.ldata.end() );
537: };
538: 
539: 
540: //! %ldata field accessor function
541: /*!
542:  *  This method allows access to the data stored in the \ref ldata field.
543:  * \return The ldata vector.
544:  *
545:  * \code
546:  * 	//================
547:  *	//Usage example:
548:  *	//================
549:  *		// Data set up
550:  *			Neuron N1, N2, N3;
551:  *			vecAMORE<Con> MyvecCon;
552:  *			std::vector<int> result;
553:  *			std::vector<ConSharedPtr> vcA, vcB;
554:  *
555:  *			N1.setId(10);
556:  *			N2.setId(20);
557:  *			N3.setId(30);
558:  *
559:  *		// Test
560:  *			ConSharedPtr ptCon( new Con(&N1, 1.13) );  	// Create new Con and initialize ptCon
561:  *			vcA.push_back(ptCon);						// push_back
562:  *			ptCon.reset( new Con(&N2, 2.22) );			// create new Con and assign to ptCon
563:  *			vcA.push_back(ptCon);						// push_back
564:  *			ptCon.reset(  new Con(&N3, 3.33) );			// create new Con and assign to ptCon
565:  *			vcA.push_back(ptCon);						// push_back
566:  *
567:  *			MyvecCon.setLdata(vcA);
568:  *			vcB = MyvecCon.getLdata();
569:  *
570:  *			result.push_back(vcB.at(0)->getFromId());
571:  *			result.push_back(vcB.at(1)->getFromId());
572:  *			result.push_back(vcB.at(2)->getFromId());
573:  * 		// After execution of the code shown above, result is an integer vector with values 10, 20, 30.
574:  * \endcode
575:  *
576:  * \sa setLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
577:  */
578: template <typename T> std::vector< boost::shared_ptr<T>  > vecAMORE<T>::getLdata() {
579: 	return ldata;
580: };
581: 
582: 
583: 
584: //! %ldata field accessor function
585: /*!
586:  *  This method sets the value of the data stored in the \ref ldata field.
587:  * \param v The vector of smart pointers to be stored in the ldata field
588:  * \sa getLdata and the unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
589:  */
590: template <typename T> void vecAMORE<T>::setLdata(std::vector< boost::shared_ptr<T>  > v) {
591: 	ldata=v;
592: };
593: 
594: 
595: //! Returns the size or length of the vector
596: /*!
597:  *  This method returns the size of the vector.
598:  *  In the classes derived from vecAMORE<T> this is aliased as numOfCons, numOfNeurons and numOfLayers.
599:  * 	The unit test files, e.g., runit.Cpp.vecAMORE.R, for usage examples.
600:  */
601: template <typename T> int vecAMORE<T>::size() {
602: 	return ldata.size() ;
603: };
604: 
605:  /*
606:  * vecCon.cpp
607:  *
608:  *  Created on: 26/05/2011
609:  *      Author: mcasl
610:  */
611: 
612: 
613: 
614: 
615: //! Size of the vecCon object
616: /*!
617:  * This function returns the size of the vecCon object, that is to say, the number of Con objects it contains.
618:  * \return The size of the vector
619:  *
620:  *  \code
621:  *  //================
622:  *  //Usage example:
623:  *  //================
624:  * 	// Data set up
625:  *		Con Con1, Con2, Con3;
626:  *		Neuron N1, N2, N3;
627:  *		vecCon MyvecCon;
628:  *		std::vector<int> result;
629:  *
630:  *		N1.setId(10);
631:  *		N2.setId(20);
632:  *		N3.setId(30);
633:  *
634:  *		Con1.setFromNeuron(&N1);
635:  *		Con2.setFromNeuron(&N2);
636:  *		Con3.setFromNeuron(&N3);
637:  *
638:  *		Con1.setWeight(1.01);
639:  *		Con2.setWeight(22.02);
640:  *		Con3.setWeight(333.03);
641:  *
642:  *	// Test
643:  *		result.push_back(MyvecCon.numOfCons());
644:  *		MyvecCon.push_back(Con1);
645:  *		result.push_back(MyvecCon.numOfCons());
646:  *		MyvecCon.push_back(Con2);
647:  *		result.push_back(MyvecCon.numOfCons());
648:  *		MyvecCon.push_back(Con3);
649:  *		result.push_back(MyvecCon.numOfCons());
650:  *	// Now, result contains a numeric vector with values 0, 1, 2, and 3.
651:  * \endcode
652:  *
653:  * \sa vecAMORE::size (alias)
654:  */
655: int  vecCon::numOfCons() {
656: 	return ldata.size();
657: }
658: 
659: 
660: 
661: //! Getter of the Id values of the vector of Cons
662: /*!
663:  * This function returns the Id's of the neurons referred to by the vector of Cons.
664:  * \return An std::vector<int> that contains the Ids
665:  *
666:  * \code
667:  *  //================
668:  *  //Usage example:
669:  *  //================
670:  * 	// Data set up
671:  *		Con Con1, Con2, Con3;
672:  *		Neuron N1, N2, N3;
673:  *		vecCon MyvecCon;
674:  *		std::vector<int> result;
675:  *
676:  *		N1.setId(10);
677:  *		N2.setId(20);
678:  *		N3.setId(30);
679: 
680:  *		Con1.setFromNeuron(&N1);
681:  *		Con2.setFromNeuron(&N2);
682:  *		Con3.setFromNeuron(&N3);
683:  *
684:  *		Con1.setWeight(1.01);
685:  *		Con2.setWeight(22.02);
686:  *		Con3.setWeight(333.03);
687: 
688:  *		MyvecCon.push_back(Con1);
689:  *		MyvecCon.push_back(Con2);
690:  *		MyvecCon.push_back(Con3);
691: 
692:  *		MyvecCon.show() ;
693:  *		MyvecCon.validate();
694:  *
695:  *	// Test
696:  *		result=MyvecCon.getFromId();
697:  *	// Now result is a vector that contains the values 10, 20 and 30.
698:  *
699:  * \endcode
700:  */
701: std::vector<int>  vecCon::getFromId() {
702: 	std::vector<int> result;
703: 	result.reserve(numOfCons());
704: 	for(std::vector<Con>::iterator itr = ldata.begin();   itr != ldata.end();   itr++)	{ result.push_back(itr->getFromId()); }
705: 	return result;
706: }
707: 
708: 
709: 
710: //
711: //
712: //
713: //void vecCon::populate	( std::vector<Neuron> FROM, std::vector<double> WEIGHT){
714: //
715: //	BEGIN_RCPP
716: //	Con con;
717: //	if (FROM.size() != WEIGHT.size() ) { throw std::range_error("[vecCon::populate]: Error, FROM.size() != WEIGHT.size()"); }
718: //	ldata.reserve(ldata.size() + FROM.size());
719: //	for( std::vector<int>::iterator itrFROM=FROM.begin(), std::vector<double>::iterator itrWEIGHT = WEIGHT.begin()	;   itrFROM != FROM.end();	itrFROM++, itrWEIGHT++)	{
720: //
721: //		new();
722: //
723: //		ldata.push_back(
724: //		)
725: //	}
726: //
727: //
728: //	END_RCPP
729: //}
730: //	push_back(gCon$new(from=f, weight=w))}, FROM, WEIGHT)
731: 
732: 
733: 
734: /*
735:  *
736:  * 	initialize=function(con, ...){
737: 					if (missing(con)){
738: 						callSuper(...)
739: 					} else {
740: 						push_back(con)
741: 						return(.self)
742: 					}
743: 				},
744: 
745: 
746: 				getWeight = function(FROM, ...){
747: 					if (missing(FROM)) {
748: 						return(sapply(ldata,function(x) { x$getWeight(...)}))
749: 					} else {
750: 						return(select(FROM)$getWeight(...))
751: 					}
752: 				},
753: 
754: 				getFrom = function(...){
755: 					return(sapply(ldata,function(x) { x$getFrom(...)}))
756: 				},
757: 
758: 
759: 				setWeight= function(value, FROM, ...) {
760: 					value <- c(value, recursive=TRUE)
761: 					if (missing(FROM)) {
762: 						if(numOfCons(...)!=length(value)) { stop("[listCon setWeight error]: Incorrect length(value)" )}
763: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata, value)	-> DontMakeNoise
764: 					} else {
765: 						if(length(FROM)!=length(value)) { stop("[listCon setWeight(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
766: 						myMatch <- match(FROM, getFromId(...))
767: 						if (any(is.na(myMatch))) {stop("[listCon setWeight(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
768: 						mapply(FUN=function(x,w){x$setWeight(w)}, ldata[myMatch], value)	-> DontMakeNoise
769: 					}
770: 				},
771: 
772: 				setFrom= function(value, FROM, ...) {
773: 					value <- c(value, recursive=TRUE)
774: 					if (missing(FROM)) {
775: 						if(numOfCons(...)!=length(value)) { stop("[listCon setFrom error]: Incorrect length(value)" )}
776: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata, value)	-> DontMakeNoise
777: 					} else {
778: 						if(length(FROM)!=length(value)) { stop("[listCon setFrom(FROM=\"numeric\") error]:  Please, provide as many values as FROM slots you want to set." )}
779: 						myMatch <- match(FROM, getFromId(...))
780: 						if (any(is.na(myMatch))) {stop("[listCon setFrom(FROM=\"numeric\")]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
781: 						mapply(FUN=function(x,f){x$setFrom(f)}, ldata[myMatch], value)	-> DontMakeNoise
782: 					}
783: 				},
784: 
785: 				delete = function(FROM, ...) {
786: 					fromIds <- getFromId(...)
787: 					delIds  <- seq(along=fromIds)[fromIds %in% FROM]
788: 					if (length(delIds)>0) {
789: 						ldata <<- ldata[-delIds]
790: 					}
791: 				},
792: 
793: 				select=function(FROM, ...){
794: 					fromObject <- getFromId(...)
795: 					myMatch <- match(FROM,  fromObject)
796: 					if (any(is.na(myMatch))) {stop("[listCon select Error]: Your FROM vector contains values that were not found by the .self$getFrom() call.")}
797: 					idx <- seq(along=ldata) [- myMatch]
798: 					selfClone <- copy(shallow=FALSE)
799: 					selfClone$delete(FROM=fromObject[idx])
800: 					return(selfClone)
801: 				},
802: 
803: 				numOfCons=function(...) {
804: 					return(length(ldata))
805: 				},
806: 
807: 				validate=function(...){
808: 					'Object validator for internal coherence.
809: 							'
810: 					lapply(ldata, function(x){if (!is(x,"Con")) {stop("[listAMORE validate]: Element is not an AMORElistElement")}  })
811: 					if (anyDuplicated(lapply(ldata, function(x){x$getFrom(...)}))>0) {stop("[listCon: Validation] Con@from duplication error")} else {}
812: 					lapply(ldata, function(x){x$validate(...)})
813: 					return(TRUE)
814:  *
815:  *
816:  */
817:  /*
818:  * Neuron.cpp
819:  *
820:  *  Created on: 25/05/2011
821:  *      Author: mcasl
822:  */
823: 
824: #ifndef INLINE_R
825: 
826: #include "Neuron.h"
827: 
828: #endif /* INLINE_R */
829: 
830: 
831: int Neuron::getId() {
832: 	return Id;
833: }
834: 
835: void Neuron::setId(int id) {
836: 	Id=id;
837: }
838: 
839: 
840: 
841: 
842: 
843: 
844: 
845: 
846: // declarations
847: extern "C" {
848: SEXP file410bbb1c( ) ;
849: }
850: 
851: // definition
852: 
853: SEXP file410bbb1c(  ){
854: BEGIN_RCPP
855: 
856: 			// Data set up
857: 			Con Con1, Con2, Con3;
858: 			Neuron N1, N2, N3;
859: 			vecCon MyvecCon;
860: 			std::vector<int> result;
861: 			
862: 			N1.setId(10);
863: 			N2.setId(20);
864: 			N3.setId(30);
865: 			
866: 			Con1.setFromNeuron(&N1);
867: 			Con2.setFromNeuron(&N2);
868: 			Con3.setFromNeuron(&N3);
869: 			
870: 			Con1.setWeight(1.01);
871: 			Con2.setWeight(22.02);
872: 			Con3.setWeight(333.03);			
873: 			
874: 			// Test
875: 			result.push_back(MyvecCon.numOfCons());
876: 			MyvecCon.push_back(Con1);
877: 			result.push_back(MyvecCon.numOfCons());
878: 			MyvecCon.push_back(Con2);
879: 			result.push_back(MyvecCon.numOfCons());
880: 			MyvecCon.push_back(Con3);
881: 			result.push_back(MyvecCon.numOfCons());
882: 						
883: 			return wrap(result);
884: 			
885: END_RCPP
886: }
887: 
888: 
Timing stopped at: 1.906 0.348 2.504 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created! file410bbb1c.cpp:227: error: redefinition of 'Con::Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:18: error: 'Con::Con()' previously defined here
file410bbb1c.cpp:236: error: redefinition of 'Con::Con(Neuron*, double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:27: error: 'Con::Con(Neuron*, double)' previously defined here
file410bbb1c.cpp:241: error: redefinition of 'Con::~Con()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:32: error: 'Con::~Con()' previously defined here
file410bbb1c.cpp:268: error: redefinition of 'Neuron* Con::getFromNeuron()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:59: error: 'Neuron* Con::getFromNeuron()' previously defined here
file410bbb1c.cpp:279: error: redefinition of 'void Con::setFromNeuron(Neuron*)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:70: error: 'void Con::setFromNeuron(Neuron*)' previously defined here
file410bbb1c.cpp:306: error: redefinition of 'int Con::getFromId()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:97: error: 'int Con::getFromId()' previously defined here
file410bbb1c.cpp:336: error: redefinition of 'double Con::getWeight()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:127: error: 'double Con::getWeight()' previously defined here
file410bbb1c.cpp:368: error: redefinition of 'void Con::setWeight(double)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:159: error: 'void Con::setWeight(double)' previously defined here
file410bbb1c.cpp:380: error: redefinition of 'bool Con::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:171: error: 'bool Con::show()' previously defined here
file410bbb1c.cpp:394: error: redefinition of 'bool Con::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/Con.cpp:185: error: 'bool Con::validate()' previously defined here
file410bbb1c.cpp:446: error: redefinition of 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:45: error: 'void vecAMORE<T>::push_back(boost::shared_ptr<X>)' previously declared here
file410bbb1c.cpp:457: error: redefinition of 'bool vecAMORE<T>::show()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:56: error: 'bool vecAMORE<T>::show()' previously declared here
file410bbb1c.cpp:472: error: redefinition of 'bool vecAMORE<T>::validate()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:71: error: 'bool vecAMORE<T>::validate()' previously declared here
file410bbb1c.cpp:534: error: redefinition of 'void vecAMORE<T>::append(vecAMORE<T>)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:133: error: 'void vecAMORE<T>::append(vecAMORE<T>)' previously declared here
file410bbb1c.cpp:578: error: redefinition of 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:177: error: 'std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > > vecAMORE<T>::getLdata()' previously declared here
file410bbb1c.cpp:590: error: redefinition of 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:189: error: 'void vecAMORE<T>::setLdata(std::vector<boost::shared_ptr<X>, std::allocator<boost::shared_ptr<X> > >)' previously declared here
file410bbb1c.cpp:601: error: redefinition of 'int vecAMORE<T>::size()'
/Users/mcasl/pc-ule/Trabajo/investigacion/AMORE/AMORE-WC/AMORE-WC/pkg/AMORE/src/vecAMORE.cpp:200: error: 'int vecAMORE<T>::size()' previously declared here
file410bbb1c.cpp: In member function 'std::vector<int, std::allocator<int> > vecCon::getFromId()':
file410bbb1c.cpp:704: error: conversion from '__gnu_cxx::__normal_iterator<boost::shared_ptr<Con>*, std::vector<boost::shared_ptr<Con>, std::allocator<boost::shared_ptr<Con> > > >' to non-scalar type '__